import { SvelteComponent, init, safe_not_equal, space, element, claim_space, claim_element, children, detach, attr, toggle_class, insert_hydration, listen, prevent_default, group_outros, transition_out, check_outros, transition_in, run_all, createEventDispatcher, set_input_value, stop_propagation, action_destroyer, bubble, binding_callbacks, text, claim_text, set_data, noop, create_component, claim_component, mount_component, destroy_component, HtmlTagHydration, empty, claim_html_tag, create_slot, add_render_callback, set_style, append_hydration, add_iframe_resize_listener, resize_observer_content_box, update_slot_base, get_all_dirty_from_scope, get_slot_changes, onMount, ensure_array_like, update_keyed_each, outro_and_destroy_block, tick, ResizeObserverSingleton, svg_element, claim_svg_element, is_function, onDestroy, bind, add_flush_callback, afterUpdate, globals, get_svelte_dataset, null_to_empty, flush, assign, get_spread_update, get_spread_object } from "../../../svelte/svelte.js";
import "../../../svelte/svelte-submodules.js";
import { M as MarkdownCode, F as Copy, B as Block, S as Static } from "./2.DuavqcSm.js";
import { d as dequal } from "./index.DTU9giFV.js";
import { U as Upload } from "./Upload.Pi-H1yNh.js";
/* empty css                                                    */
import { M as Maximize, a as Minimize } from "./Minimize.BNzzPy3I.js";
import { d as dsvFormat } from "./dsv.CKxpOsHB.js";
import { default as default2 } from "./Example.Cg4HFUYK.js";
function create_if_block_2$4(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      this.h();
    },
    l(nodes) {
      input = claim_element(nodes, "INPUT", { role: true, tabindex: true, class: true });
      this.h();
    },
    h() {
      attr(input, "role", "textbox");
      attr(input, "tabindex", "-1");
      attr(input, "class", "svelte-svrul5");
      toggle_class(
        input,
        "header",
        /*header*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert_hydration(target, input, anchor);
      ctx[24](input);
      set_input_value(
        input,
        /*_value*/
        ctx[11]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[25]
          ),
          listen(
            input,
            "blur",
            /*handle_blur*/
            ctx[14]
          ),
          listen(input, "mousedown", stop_propagation(
            /*mousedown_handler*/
            ctx[21]
          )),
          listen(input, "mouseup", stop_propagation(
            /*mouseup_handler*/
            ctx[22]
          )),
          listen(input, "click", stop_propagation(
            /*click_handler*/
            ctx[23]
          )),
          action_destroyer(
            /*use_focus*/
            ctx[13].call(null, input)
          ),
          listen(
            input,
            "keydown",
            /*handle_keydown*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*_value*/
      2048 && input.value !== /*_value*/
      ctx2[11]) {
        set_input_value(
          input,
          /*_value*/
          ctx2[11]
        );
      }
      if (dirty & /*header*/
      16) {
        toggle_class(
          input,
          "header",
          /*header*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$1(ctx) {
  let t_value = (
    /*editable*/
    (ctx[8] ? (
      /*display_text*/
      ctx[12]
    ) : (
      /*display_value*/
      ctx[2] || /*display_text*/
      ctx[12]
    )) + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*editable, display_text, display_value*/
      4356 && t_value !== (t_value = /*editable*/
      (ctx2[8] ? (
        /*display_text*/
        ctx2[12]
      ) : (
        /*display_value*/
        ctx2[2] || /*display_text*/
        ctx2[12]
      )) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1$4(ctx) {
  let markdowncode;
  let current;
  markdowncode = new MarkdownCode({
    props: {
      message: (
        /*display_text*/
        ctx[12].toLocaleString()
      ),
      latex_delimiters: (
        /*latex_delimiters*/
        ctx[6]
      ),
      line_breaks: (
        /*line_breaks*/
        ctx[7]
      ),
      chatbot: false,
      root: (
        /*root*/
        ctx[9]
      )
    }
  });
  return {
    c() {
      create_component(markdowncode.$$.fragment);
    },
    l(nodes) {
      claim_component(markdowncode.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(markdowncode, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdowncode_changes = {};
      if (dirty & /*display_text*/
      4096)
        markdowncode_changes.message = /*display_text*/
        ctx2[12].toLocaleString();
      if (dirty & /*latex_delimiters*/
      64)
        markdowncode_changes.latex_delimiters = /*latex_delimiters*/
        ctx2[6];
      if (dirty & /*line_breaks*/
      128)
        markdowncode_changes.line_breaks = /*line_breaks*/
        ctx2[7];
      if (dirty & /*root*/
      512)
        markdowncode_changes.root = /*root*/
        ctx2[9];
      markdowncode.$set(markdowncode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdowncode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdowncode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdowncode, detaching);
    }
  };
}
function create_if_block$5(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*display_text*/
        ctx[12],
        target,
        anchor
      );
      insert_hydration(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*display_text*/
      4096)
        html_tag.p(
          /*display_text*/
          ctx2[12]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_fragment$8(ctx) {
  let t;
  let span;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*edit*/
    ctx[1] && create_if_block_2$4(ctx)
  );
  const if_block_creators = [create_if_block$5, create_if_block_1$4, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*datatype*/
      ctx2[5] === "html"
    )
      return 0;
    if (
      /*datatype*/
      ctx2[5] === "markdown"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      span = element("span");
      if_block1.c();
      this.h();
    },
    l(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {
        tabindex: true,
        role: true,
        style: true,
        class: true,
        "data-editable": true,
        placeholder: true
      });
      var span_nodes = children(span);
      if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "tabindex", "0");
      attr(span, "role", "button");
      attr(
        span,
        "style",
        /*styling*/
        ctx[3]
      );
      attr(span, "class", "table-cell-text svelte-svrul5");
      attr(
        span,
        "data-editable",
        /*editable*/
        ctx[8]
      );
      attr(span, "placeholder", " ");
      toggle_class(
        span,
        "edit",
        /*edit*/
        ctx[1]
      );
      toggle_class(
        span,
        "expanded",
        /*is_expanded*/
        ctx[10]
      );
      toggle_class(
        span,
        "multiline",
        /*header*/
        ctx[4]
      );
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t, anchor);
      insert_hydration(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "click",
            /*handle_click*/
            ctx[16]
          ),
          listen(
            span,
            "keydown",
            /*handle_keydown*/
            ctx[15]
          ),
          listen(span, "focus", prevent_default(
            /*focus_handler*/
            ctx[20]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*edit*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$4(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(span, null);
      }
      if (!current || dirty & /*styling*/
      8) {
        attr(
          span,
          "style",
          /*styling*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*editable*/
      256) {
        attr(
          span,
          "data-editable",
          /*editable*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*edit*/
      2) {
        toggle_class(
          span,
          "edit",
          /*edit*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*is_expanded*/
      1024) {
        toggle_class(
          span,
          "expanded",
          /*is_expanded*/
          ctx2[10]
        );
      }
      if (!current || dirty & /*header*/
      16) {
        toggle_class(
          span,
          "multiline",
          /*header*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(span);
      }
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function truncate_text(text2, max_length = null) {
  const str = String(text2);
  if (!max_length || str.length <= max_length)
    return str;
  return str.slice(0, max_length) + "...";
}
function instance$8($$self, $$props, $$invalidate) {
  let _value;
  let display_text;
  let { edit } = $$props;
  let { value = "" } = $$props;
  let { display_value = null } = $$props;
  let { styling = "" } = $$props;
  let { header = false } = $$props;
  let { datatype = "str" } = $$props;
  let { latex_delimiters } = $$props;
  let { clear_on_focus = false } = $$props;
  let { line_breaks = true } = $$props;
  let { editable = true } = $$props;
  let { root } = $$props;
  let { max_chars = null } = $$props;
  const dispatch = createEventDispatcher();
  let is_expanded = false;
  let { el } = $$props;
  function use_focus(node) {
    if (clear_on_focus) {
      $$invalidate(11, _value = "");
    }
    requestAnimationFrame(() => {
      node.focus();
    });
    return {};
  }
  function handle_blur({ currentTarget }) {
    $$invalidate(17, value = currentTarget.value);
    dispatch("blur");
  }
  function handle_keydown(event) {
    if (event.key === "Enter") {
      if (edit) {
        $$invalidate(17, value = _value);
        dispatch("blur");
      } else if (!header) {
        $$invalidate(10, is_expanded = !is_expanded);
      }
    }
    dispatch("keydown", event);
  }
  function handle_click() {
    if (!edit && !header) {
      $$invalidate(10, is_expanded = !is_expanded);
    }
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  function input_input_handler() {
    _value = this.value;
    $$invalidate(11, _value), $$invalidate(17, value);
  }
  $$self.$$set = ($$props2) => {
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("value" in $$props2)
      $$invalidate(17, value = $$props2.value);
    if ("display_value" in $$props2)
      $$invalidate(2, display_value = $$props2.display_value);
    if ("styling" in $$props2)
      $$invalidate(3, styling = $$props2.styling);
    if ("header" in $$props2)
      $$invalidate(4, header = $$props2.header);
    if ("datatype" in $$props2)
      $$invalidate(5, datatype = $$props2.datatype);
    if ("latex_delimiters" in $$props2)
      $$invalidate(6, latex_delimiters = $$props2.latex_delimiters);
    if ("clear_on_focus" in $$props2)
      $$invalidate(18, clear_on_focus = $$props2.clear_on_focus);
    if ("line_breaks" in $$props2)
      $$invalidate(7, line_breaks = $$props2.line_breaks);
    if ("editable" in $$props2)
      $$invalidate(8, editable = $$props2.editable);
    if ("root" in $$props2)
      $$invalidate(9, root = $$props2.root);
    if ("max_chars" in $$props2)
      $$invalidate(19, max_chars = $$props2.max_chars);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    131072) {
      $$invalidate(11, _value = value);
    }
    if ($$self.$$.dirty & /*is_expanded, value, display_value, max_chars*/
    656388) {
      $$invalidate(12, display_text = is_expanded ? value : truncate_text(display_value || value, max_chars));
    }
  };
  return [
    el,
    edit,
    display_value,
    styling,
    header,
    datatype,
    latex_delimiters,
    line_breaks,
    editable,
    root,
    is_expanded,
    _value,
    display_text,
    use_focus,
    handle_blur,
    handle_keydown,
    handle_click,
    value,
    clear_on_focus,
    max_chars,
    focus_handler,
    mousedown_handler2,
    mouseup_handler,
    click_handler,
    input_binding,
    input_input_handler
  ];
}
class EditableCell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, {
      edit: 1,
      value: 17,
      display_value: 2,
      styling: 3,
      header: 4,
      datatype: 5,
      latex_delimiters: 6,
      clear_on_focus: 18,
      line_breaks: 7,
      editable: 8,
      root: 9,
      max_chars: 19,
      el: 0
    });
  }
}
const get_tfoot_slot_changes = (dirty) => ({});
const get_tfoot_slot_context = (ctx) => ({});
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
const get_tbody_slot_changes = (dirty) => ({
  item: dirty[0] & /*visible*/
  1024,
  index: dirty[0] & /*visible*/
  1024
});
const get_tbody_slot_context = (ctx) => ({
  item: (
    /*item*/
    ctx[37].data
  ),
  index: (
    /*item*/
    ctx[37].index
  )
});
const get_thead_slot_changes = (dirty) => ({});
const get_thead_slot_context = (ctx) => ({});
function create_if_block$4(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*visible*/
    ctx[10]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[37].data[0].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$$scope, visible*/
      2098176) {
        each_value = ensure_array_like(
          /*visible*/
          ctx2[10]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function fallback_block(ctx) {
  let t;
  return {
    c() {
      t = text("Missing Table Row\n						");
    },
    l(nodes) {
      t = claim_text(nodes, "Missing Table Row\n						");
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let first;
  let current;
  const tbody_slot_template = (
    /*#slots*/
    ctx[22].tbody
  );
  const tbody_slot = create_slot(
    tbody_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_tbody_slot_context
  );
  const tbody_slot_or_fallback = tbody_slot || fallback_block();
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (tbody_slot_or_fallback)
        tbody_slot_or_fallback.c();
      this.h();
    },
    l(nodes) {
      first = empty();
      if (tbody_slot_or_fallback)
        tbody_slot_or_fallback.l(nodes);
      this.h();
    },
    h() {
      this.first = first;
    },
    m(target, anchor) {
      insert_hydration(target, first, anchor);
      if (tbody_slot_or_fallback) {
        tbody_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (tbody_slot) {
        if (tbody_slot.p && (!current || dirty[0] & /*$$scope, visible*/
        2098176)) {
          update_slot_base(
            tbody_slot,
            tbody_slot_template,
            ctx,
            /*$$scope*/
            ctx[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[21]
            ) : get_slot_changes(
              tbody_slot_template,
              /*$$scope*/
              ctx[21],
              dirty,
              get_tbody_slot_changes
            ),
            get_tbody_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tbody_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tbody_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      if (tbody_slot_or_fallback)
        tbody_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let svelte_virtual_table_viewport;
  let div;
  let table;
  let thead;
  let thead_resize_listener;
  let t0;
  let tbody;
  let t1;
  let tfoot;
  let tfoot_resize_listener;
  let table_resize_listener;
  let current;
  let mounted;
  let dispose;
  const thead_slot_template = (
    /*#slots*/
    ctx[22].thead
  );
  const thead_slot = create_slot(
    thead_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_thead_slot_context
  );
  let if_block = (
    /*visible*/
    ctx[10].length && /*visible*/
    ctx[10][0].data.length && create_if_block$4(ctx)
  );
  const tfoot_slot_template = (
    /*#slots*/
    ctx[22].tfoot
  );
  const tfoot_slot = create_slot(
    tfoot_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_tfoot_slot_context
  );
  return {
    c() {
      svelte_virtual_table_viewport = element("svelte-virtual-table-viewport");
      div = element("div");
      table = element("table");
      thead = element("thead");
      if (thead_slot)
        thead_slot.c();
      t0 = space();
      tbody = element("tbody");
      if (if_block)
        if_block.c();
      t1 = space();
      tfoot = element("tfoot");
      if (tfoot_slot)
        tfoot_slot.c();
      this.h();
    },
    l(nodes) {
      svelte_virtual_table_viewport = claim_element(nodes, "SVELTE-VIRTUAL-TABLE-VIEWPORT", {});
      var svelte_virtual_table_viewport_nodes = children(svelte_virtual_table_viewport);
      div = claim_element(svelte_virtual_table_viewport_nodes, "DIV", {});
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true, style: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      if (thead_slot)
        thead_slot.l(thead_nodes);
      thead_nodes.forEach(detach);
      t0 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      if (if_block)
        if_block.l(tbody_nodes);
      tbody_nodes.forEach(detach);
      t1 = claim_space(table_nodes);
      tfoot = claim_element(table_nodes, "TFOOT", { class: true });
      var tfoot_nodes = children(tfoot);
      if (tfoot_slot)
        tfoot_slot.l(tfoot_nodes);
      tfoot_nodes.forEach(detach);
      table_nodes.forEach(detach);
      div_nodes.forEach(detach);
      svelte_virtual_table_viewport_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(thead, "class", "thead svelte-y11bhb");
      add_render_callback(() => (
        /*thead_elementresize_handler*/
        ctx[23].call(thead)
      ));
      attr(tbody, "class", "tbody svelte-y11bhb");
      attr(tfoot, "class", "tfoot svelte-y11bhb");
      add_render_callback(() => (
        /*tfoot_elementresize_handler*/
        ctx[25].call(tfoot)
      ));
      attr(table, "class", "table svelte-y11bhb");
      set_style(table, "height", height);
      set_style(
        table,
        "--bw-svt-p-top",
        /*top*/
        ctx[8] + "px"
      );
      set_style(
        table,
        "--bw-svt-p-bottom",
        /*bottom*/
        ctx[4] + "px"
      );
      set_style(
        table,
        "--bw-svt-head-height",
        /*head_height*/
        ctx[6] + "px"
      );
      set_style(
        table,
        "--bw-svt-foot-height",
        /*foot_height*/
        ctx[7] + "px"
      );
      set_style(
        table,
        "--bw-svt-avg-row-height",
        /*average_height*/
        ctx[2] + "px"
      );
      set_style(
        table,
        "--max-height",
        /*max_height*/
        ctx[0] + "px"
      );
      toggle_class(
        table,
        "disable-scroll",
        /*disable_scroll*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, svelte_virtual_table_viewport, anchor);
      append_hydration(svelte_virtual_table_viewport, div);
      append_hydration(div, table);
      append_hydration(table, thead);
      if (thead_slot) {
        thead_slot.m(thead, null);
      }
      thead_resize_listener = add_iframe_resize_listener(
        thead,
        /*thead_elementresize_handler*/
        ctx[23].bind(thead)
      );
      append_hydration(table, t0);
      append_hydration(table, tbody);
      if (if_block)
        if_block.m(tbody, null);
      ctx[24](tbody);
      append_hydration(table, t1);
      append_hydration(table, tfoot);
      if (tfoot_slot) {
        tfoot_slot.m(tfoot, null);
      }
      tfoot_resize_listener = add_iframe_resize_listener(
        tfoot,
        /*tfoot_elementresize_handler*/
        ctx[25].bind(tfoot)
      );
      ctx[26](table);
      table_resize_listener = resize_observer_content_box.observe(
        table,
        /*table_elementresizecontentbox_handler*/
        ctx[27].bind(table)
      );
      current = true;
      if (!mounted) {
        dispose = listen(
          table,
          "scroll",
          /*handle_scroll*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (thead_slot) {
        if (thead_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            thead_slot,
            thead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              thead_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_thead_slot_changes
            ),
            get_thead_slot_context
          );
        }
      }
      if (
        /*visible*/
        ctx2[10].length && /*visible*/
        ctx2[10][0].data.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*visible*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tbody, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (tfoot_slot) {
        if (tfoot_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            tfoot_slot,
            tfoot_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              tfoot_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_tfoot_slot_changes
            ),
            get_tfoot_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*top*/
      256) {
        set_style(
          table,
          "--bw-svt-p-top",
          /*top*/
          ctx2[8] + "px"
        );
      }
      if (!current || dirty[0] & /*bottom*/
      16) {
        set_style(
          table,
          "--bw-svt-p-bottom",
          /*bottom*/
          ctx2[4] + "px"
        );
      }
      if (!current || dirty[0] & /*head_height*/
      64) {
        set_style(
          table,
          "--bw-svt-head-height",
          /*head_height*/
          ctx2[6] + "px"
        );
      }
      if (!current || dirty[0] & /*foot_height*/
      128) {
        set_style(
          table,
          "--bw-svt-foot-height",
          /*foot_height*/
          ctx2[7] + "px"
        );
      }
      if (!current || dirty[0] & /*average_height*/
      4) {
        set_style(
          table,
          "--bw-svt-avg-row-height",
          /*average_height*/
          ctx2[2] + "px"
        );
      }
      if (!current || dirty[0] & /*max_height*/
      1) {
        set_style(
          table,
          "--max-height",
          /*max_height*/
          ctx2[0] + "px"
        );
      }
      if (!current || dirty[0] & /*disable_scroll*/
      2) {
        toggle_class(
          table,
          "disable-scroll",
          /*disable_scroll*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(thead_slot, local);
      transition_in(if_block);
      transition_in(tfoot_slot, local);
      current = true;
    },
    o(local) {
      transition_out(thead_slot, local);
      transition_out(if_block);
      transition_out(tfoot_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_virtual_table_viewport);
      }
      if (thead_slot)
        thead_slot.d(detaching);
      thead_resize_listener();
      if (if_block)
        if_block.d();
      ctx[24](null);
      if (tfoot_slot)
        tfoot_slot.d(detaching);
      tfoot_resize_listener();
      ctx[26](null);
      table_resize_listener();
      mounted = false;
      dispose();
    }
  };
}
let height = "100%";
function get_computed_px_amount(elem, property) {
  if (!elem) {
    return 0;
  }
  const compStyle = getComputedStyle(elem);
  let x = parseInt(compStyle.getPropertyValue(property));
  return x;
}
function instance$7($$self, $$props, $$invalidate) {
  let sortedItems;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { items = [] } = $$props;
  let { max_height } = $$props;
  let { actual_height } = $$props;
  let { table_scrollbar_width } = $$props;
  let { start = 0 } = $$props;
  let { end = 20 } = $$props;
  let { selected } = $$props;
  let { disable_scroll = false } = $$props;
  let average_height = 30;
  let bottom = 0;
  let contents;
  let head_height = 0;
  let foot_height = 0;
  let height_map = [];
  let mounted;
  let rows;
  let top = 0;
  let viewport;
  let viewport_height = 200;
  let visible = [];
  let viewport_box;
  const is_browser = typeof window !== "undefined";
  const raf = is_browser ? window.requestAnimationFrame : (cb) => cb();
  let content_height = 0;
  async function refresh_height_map(_items) {
    var _a;
    if (viewport_height === 0) {
      return;
    }
    $$invalidate(6, head_height = ((_a = viewport.querySelector(".thead")) == null ? void 0 : _a.getBoundingClientRect().height) || 0);
    await tick();
    const { scrollTop } = viewport;
    $$invalidate(15, table_scrollbar_width = viewport.offsetWidth - viewport.clientWidth);
    content_height = top - (scrollTop - head_height);
    let i = start;
    while (content_height < max_height && i < _items.length) {
      let row = rows[i - start];
      if (!row) {
        $$invalidate(13, end = i + 1);
        await tick();
        row = rows[i - start];
      }
      let _h = row == null ? void 0 : row.getBoundingClientRect().height;
      if (!_h) {
        _h = average_height;
      }
      const row_height = height_map[i] = _h;
      content_height += row_height;
      i += 1;
    }
    $$invalidate(13, end = i);
    const remaining = _items.length - end;
    const scrollbar_height = viewport.offsetHeight - viewport.clientHeight;
    if (scrollbar_height > 0) {
      content_height += scrollbar_height;
    }
    let filtered_height_map = height_map.filter((v) => typeof v === "number");
    $$invalidate(2, average_height = filtered_height_map.reduce((a, b) => a + b, 0) / filtered_height_map.length);
    $$invalidate(4, bottom = remaining * average_height);
    height_map.length = _items.length;
    await tick();
    if (!max_height) {
      $$invalidate(14, actual_height = content_height + 1);
    } else if (content_height < max_height) {
      $$invalidate(14, actual_height = content_height + 2);
    } else {
      $$invalidate(14, actual_height = max_height);
    }
    await tick();
  }
  async function scroll_and_render(n) {
    raf(async () => {
      if (typeof n !== "number")
        return;
      const direction = typeof n !== "number" ? false : is_in_view(n);
      if (direction === true) {
        return;
      }
      if (direction === "back") {
        await scroll_to_index(n, { behavior: "instant" });
      }
      if (direction === "forwards") {
        await scroll_to_index(n, { behavior: "instant" }, true);
      }
    });
  }
  function is_in_view(n) {
    const current = rows && rows[n - start];
    if (!current && n < start) {
      return "back";
    }
    if (!current && n >= end - 1) {
      return "forwards";
    }
    const { top: viewport_top } = viewport.getBoundingClientRect();
    const { top: top2, bottom: bottom2 } = current.getBoundingClientRect();
    if (top2 - viewport_top < 37) {
      return "back";
    }
    if (bottom2 - viewport_top > viewport_height) {
      return "forwards";
    }
    return true;
  }
  async function handle_scroll(e) {
    const scroll_top = viewport.scrollTop;
    rows = contents.children;
    const is_start_overflow = sortedItems.length < start;
    const row_top_border = get_computed_px_amount(rows[1], "border-top-width");
    const actual_border_collapsed_width = 0;
    if (is_start_overflow) {
      await scroll_to_index(sortedItems.length - 1, { behavior: "auto" });
    }
    let new_start = 0;
    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = rows[v].getBoundingClientRect().height;
    }
    let i = 0;
    let y = head_height + row_top_border / 2;
    let row_heights = [];
    while (i < sortedItems.length) {
      const row_height = height_map[i] || average_height;
      row_heights[i] = row_height;
      if (y + row_height + actual_border_collapsed_width > scroll_top) {
        new_start = i;
        $$invalidate(8, top = y - (head_height + row_top_border / 2));
        break;
      }
      y += row_height;
      i += 1;
    }
    new_start = Math.max(0, new_start);
    while (i < sortedItems.length) {
      const row_height = height_map[i] || average_height;
      y += row_height;
      i += 1;
      if (y > scroll_top + viewport_height) {
        break;
      }
    }
    $$invalidate(12, start = new_start);
    $$invalidate(13, end = i);
    const remaining = sortedItems.length - end;
    if (end === 0) {
      $$invalidate(13, end = 10);
    }
    $$invalidate(2, average_height = (y - head_height) / end);
    let remaining_height = remaining * average_height;
    while (i < sortedItems.length) {
      i += 1;
      height_map[i] = average_height;
    }
    $$invalidate(4, bottom = remaining_height);
    if (!isFinite(bottom)) {
      $$invalidate(4, bottom = 2e5);
    }
  }
  async function scroll_to_index(index, opts, align_end = false) {
    await tick();
    const _itemHeight = average_height;
    let distance = index * _itemHeight;
    if (align_end) {
      distance = distance - viewport_height + _itemHeight + head_height;
    }
    const scrollbar_height = viewport.offsetHeight - viewport.clientHeight;
    if (scrollbar_height > 0) {
      distance += scrollbar_height;
    }
    const _opts = {
      top: distance,
      behavior: "smooth",
      ...opts
    };
    viewport.scrollTo(_opts);
  }
  onMount(() => {
    rows = contents.children;
    $$invalidate(19, mounted = true);
    refresh_height_map(items);
  });
  function thead_elementresize_handler() {
    head_height = this.offsetHeight;
    $$invalidate(6, head_height);
  }
  function tbody_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(5, contents);
    });
  }
  function tfoot_elementresize_handler() {
    foot_height = this.offsetHeight;
    $$invalidate(7, foot_height);
  }
  function table_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(9, viewport);
    });
  }
  function table_elementresizecontentbox_handler() {
    var _a;
    viewport_box = (_a = ResizeObserverSingleton.entries.get(this)) == null ? void 0 : _a.contentRect;
    $$invalidate(3, viewport_box);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(16, items = $$props2.items);
    if ("max_height" in $$props2)
      $$invalidate(0, max_height = $$props2.max_height);
    if ("actual_height" in $$props2)
      $$invalidate(14, actual_height = $$props2.actual_height);
    if ("table_scrollbar_width" in $$props2)
      $$invalidate(15, table_scrollbar_width = $$props2.table_scrollbar_width);
    if ("start" in $$props2)
      $$invalidate(12, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(13, end = $$props2.end);
    if ("selected" in $$props2)
      $$invalidate(17, selected = $$props2.selected);
    if ("disable_scroll" in $$props2)
      $$invalidate(1, disable_scroll = $$props2.disable_scroll);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*viewport_box*/
    8) {
      viewport_height = (viewport_box == null ? void 0 : viewport_box.height) || 200;
    }
    if ($$self.$$.dirty[0] & /*items*/
    65536) {
      $$invalidate(20, sortedItems = items);
    }
    if ($$self.$$.dirty[0] & /*mounted, sortedItems*/
    1572864) {
      mounted && raf(() => refresh_height_map(sortedItems));
    }
    if ($$self.$$.dirty[0] & /*selected*/
    131072) {
      scroll_and_render(selected);
    }
    if ($$self.$$.dirty[0] & /*sortedItems, start, end, max_height, average_height*/
    1060869) {
      $$invalidate(10, visible = is_browser ? sortedItems.slice(start, end).map((data, i) => {
        return { index: i + start, data };
      }) : sortedItems.slice(0, max_height / sortedItems.length * average_height + 1).map((data, i) => {
        return { index: i + start, data };
      }));
    }
  };
  return [
    max_height,
    disable_scroll,
    average_height,
    viewport_box,
    bottom,
    contents,
    head_height,
    foot_height,
    top,
    viewport,
    visible,
    handle_scroll,
    start,
    end,
    actual_height,
    table_scrollbar_width,
    items,
    selected,
    scroll_to_index,
    mounted,
    sortedItems,
    $$scope,
    slots,
    thead_elementresize_handler,
    tbody_binding,
    tfoot_elementresize_handler,
    table_binding,
    table_elementresizecontentbox_handler
  ];
}
class VirtualTable extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$7,
      create_fragment$7,
      safe_not_equal,
      {
        items: 16,
        max_height: 0,
        actual_height: 14,
        table_scrollbar_width: 15,
        start: 12,
        end: 13,
        selected: 17,
        disable_scroll: 1,
        scroll_to_index: 18
      },
      null,
      [-1, -1]
    );
  }
  get scroll_to_index() {
    return this.$$.ctx[18];
  }
}
function create_if_block_5$2(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "10");
      attr(rect, "y", "5");
      attr(rect, "width", "4");
      attr(rect, "height", "14");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(path, "d", "M7 8L17 16M17 8L7 16");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_4$2(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "5");
      attr(rect, "y", "10");
      attr(rect, "width", "14");
      attr(rect, "height", "4");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(path, "d", "M8 7L16 17M16 7L8 17");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_3$3(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        fill: true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "6");
      attr(rect, "y", "4");
      attr(rect, "width", "12");
      attr(rect, "height", "4");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(path, "d", "M12 12V19M8 16L12 19L16 16");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "fill", "none");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_2$3(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        fill: true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "6");
      attr(rect, "y", "16");
      attr(rect, "width", "12");
      attr(rect, "height", "4");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(path, "d", "M12 12V5M8 8L12 5L16 8");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "fill", "none");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_1$3(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true,
        fill: true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        fill: true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "16");
      attr(rect, "y", "6");
      attr(rect, "width", "4");
      attr(rect, "height", "12");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(rect, "fill", "none");
      attr(path, "d", "M12 12H5M8 8L5 12L8 16");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "fill", "none");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block$3(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, width: true, height: true });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        stroke: true,
        "stroke-width": true,
        fill: true
      });
      children(rect).forEach(detach);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        fill: true,
        "stroke-linecap": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(rect, "x", "4");
      attr(rect, "y", "6");
      attr(rect, "width", "4");
      attr(rect, "height", "12");
      attr(rect, "stroke", "currentColor");
      attr(rect, "stroke-width", "2");
      attr(rect, "fill", "none");
      attr(path, "d", "M12 12H19M16 8L19 12L16 16");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "fill", "none");
      attr(path, "stroke-linecap", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, rect);
      append_hydration(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_fragment$6(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*icon*/
      ctx2[0] == "add-column-right"
    )
      return create_if_block$3;
    if (
      /*icon*/
      ctx2[0] == "add-column-left"
    )
      return create_if_block_1$3;
    if (
      /*icon*/
      ctx2[0] == "add-row-above"
    )
      return create_if_block_2$3;
    if (
      /*icon*/
      ctx2[0] == "add-row-below"
    )
      return create_if_block_3$3;
    if (
      /*icon*/
      ctx2[0] == "delete-row"
    )
      return create_if_block_4$2;
    if (
      /*icon*/
      ctx2[0] == "delete-column"
    )
      return create_if_block_5$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
  };
  return [icon];
}
class CellMenuIcons extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { icon: 0 });
  }
}
function create_if_block_2$2(ctx) {
  let button0;
  let cellmenuicons0;
  let t0;
  let t1_value = (
    /*i18n*/
    ctx[8]("dataframe.add_row_above") + ""
  );
  let t1;
  let t2;
  let button1;
  let cellmenuicons1;
  let t3;
  let t4_value = (
    /*i18n*/
    ctx[8]("dataframe.add_row_below") + ""
  );
  let t4;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  cellmenuicons0 = new CellMenuIcons({ props: { icon: "add-row-above" } });
  cellmenuicons1 = new CellMenuIcons({ props: { icon: "add-row-below" } });
  let if_block = (
    /*can_delete_rows*/
    ctx[6] && create_if_block_3$2(ctx)
  );
  return {
    c() {
      button0 = element("button");
      create_component(cellmenuicons0.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      button1 = element("button");
      create_component(cellmenuicons1.$$.fragment);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      button0 = claim_element(nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      claim_component(cellmenuicons0.$$.fragment, button0_nodes);
      t0 = claim_space(button0_nodes);
      t1 = claim_text(button0_nodes, t1_value);
      button0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      claim_component(cellmenuicons1.$$.fragment, button1_nodes);
      t3 = claim_space(button1_nodes);
      t4 = claim_text(button1_nodes, t4_value);
      button1_nodes.forEach(detach);
      t5 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      attr(button0, "class", "svelte-9g877");
      attr(button1, "class", "svelte-9g877");
    },
    m(target, anchor) {
      insert_hydration(target, button0, anchor);
      mount_component(cellmenuicons0, button0, null);
      append_hydration(button0, t0);
      append_hydration(button0, t1);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, button1, anchor);
      mount_component(cellmenuicons1, button1, null);
      append_hydration(button1, t3);
      append_hydration(button1, t4);
      insert_hydration(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[18]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*i18n*/
      256) && t1_value !== (t1_value = /*i18n*/
      ctx2[8]("dataframe.add_row_above") + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*i18n*/
      256) && t4_value !== (t4_value = /*i18n*/
      ctx2[8]("dataframe.add_row_below") + ""))
        set_data(t4, t4_value);
      if (
        /*can_delete_rows*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*can_delete_rows*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenuicons0.$$.fragment, local);
      transition_in(cellmenuicons1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(cellmenuicons0.$$.fragment, local);
      transition_out(cellmenuicons1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
        detach(t5);
        detach(if_block_anchor);
      }
      destroy_component(cellmenuicons0);
      destroy_component(cellmenuicons1);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$2(ctx) {
  let button;
  let cellmenuicons;
  let t0;
  let t1_value = (
    /*i18n*/
    ctx[8]("dataframe.delete_row") + ""
  );
  let t1;
  let current;
  let mounted;
  let dispose;
  cellmenuicons = new CellMenuIcons({ props: { icon: "delete-row" } });
  return {
    c() {
      button = element("button");
      create_component(cellmenuicons.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(cellmenuicons.$$.fragment, button_nodes);
      t0 = claim_space(button_nodes);
      t1 = claim_text(button_nodes, t1_value);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "delete svelte-9g877");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      mount_component(cellmenuicons, button, null);
      append_hydration(button, t0);
      append_hydration(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*on_delete_row*/
            ctx[4]
          ))
            ctx[4].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*i18n*/
      256) && t1_value !== (t1_value = /*i18n*/
      ctx[8]("dataframe.delete_row") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenuicons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cellmenuicons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(cellmenuicons);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2(ctx) {
  let button0;
  let cellmenuicons0;
  let t0;
  let t1_value = (
    /*i18n*/
    ctx[8]("dataframe.add_column_left") + ""
  );
  let t1;
  let t2;
  let button1;
  let cellmenuicons1;
  let t3;
  let t4_value = (
    /*i18n*/
    ctx[8]("dataframe.add_column_right") + ""
  );
  let t4;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  cellmenuicons0 = new CellMenuIcons({ props: { icon: "add-column-left" } });
  cellmenuicons1 = new CellMenuIcons({ props: { icon: "add-column-right" } });
  let if_block = (
    /*can_delete_cols*/
    ctx[7] && create_if_block_1$2(ctx)
  );
  return {
    c() {
      button0 = element("button");
      create_component(cellmenuicons0.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      button1 = element("button");
      create_component(cellmenuicons1.$$.fragment);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      button0 = claim_element(nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      claim_component(cellmenuicons0.$$.fragment, button0_nodes);
      t0 = claim_space(button0_nodes);
      t1 = claim_text(button0_nodes, t1_value);
      button0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      claim_component(cellmenuicons1.$$.fragment, button1_nodes);
      t3 = claim_space(button1_nodes);
      t4 = claim_text(button1_nodes, t4_value);
      button1_nodes.forEach(detach);
      t5 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      attr(button0, "class", "svelte-9g877");
      attr(button1, "class", "svelte-9g877");
    },
    m(target, anchor) {
      insert_hydration(target, button0, anchor);
      mount_component(cellmenuicons0, button0, null);
      append_hydration(button0, t0);
      append_hydration(button0, t1);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, button1, anchor);
      mount_component(cellmenuicons1, button1, null);
      append_hydration(button1, t3);
      append_hydration(button1, t4);
      insert_hydration(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_2*/
            ctx[20]
          ),
          listen(
            button1,
            "click",
            /*click_handler_3*/
            ctx[21]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*i18n*/
      256) && t1_value !== (t1_value = /*i18n*/
      ctx2[8]("dataframe.add_column_left") + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*i18n*/
      256) && t4_value !== (t4_value = /*i18n*/
      ctx2[8]("dataframe.add_column_right") + ""))
        set_data(t4, t4_value);
      if (
        /*can_delete_cols*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*can_delete_cols*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenuicons0.$$.fragment, local);
      transition_in(cellmenuicons1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(cellmenuicons0.$$.fragment, local);
      transition_out(cellmenuicons1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
        detach(t5);
        detach(if_block_anchor);
      }
      destroy_component(cellmenuicons0);
      destroy_component(cellmenuicons1);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$2(ctx) {
  let button;
  let cellmenuicons;
  let t0;
  let t1_value = (
    /*i18n*/
    ctx[8]("dataframe.delete_column") + ""
  );
  let t1;
  let current;
  let mounted;
  let dispose;
  cellmenuicons = new CellMenuIcons({ props: { icon: "delete-column" } });
  return {
    c() {
      button = element("button");
      create_component(cellmenuicons.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(cellmenuicons.$$.fragment, button_nodes);
      t0 = claim_space(button_nodes);
      t1 = claim_text(button_nodes, t1_value);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "delete svelte-9g877");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      mount_component(cellmenuicons, button, null);
      append_hydration(button, t0);
      append_hydration(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*on_delete_col*/
            ctx[5]
          ))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*i18n*/
      256) && t1_value !== (t1_value = /*i18n*/
      ctx[8]("dataframe.delete_column") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenuicons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cellmenuicons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(cellmenuicons);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = !/*is_header*/
  ctx[12] && /*can_add_rows*/
  ctx[11] && create_if_block_2$2(ctx);
  let if_block1 = (
    /*can_add_columns*/
    ctx[10] && create_if_block$2(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "cell-menu svelte-9g877");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration(div, t);
      if (if_block1)
        if_block1.m(div, null);
      ctx[22](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*is_header*/
      ctx2[12] && /*can_add_rows*/
      ctx2[11]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*is_header, can_add_rows*/
          6144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*can_add_columns*/
        ctx2[10]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*can_add_columns*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[22](null);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let is_header;
  let can_add_rows;
  let can_add_columns;
  let { x } = $$props;
  let { y } = $$props;
  let { on_add_row_above } = $$props;
  let { on_add_row_below } = $$props;
  let { on_add_column_left } = $$props;
  let { on_add_column_right } = $$props;
  let { row } = $$props;
  let { col_count } = $$props;
  let { row_count } = $$props;
  let { on_delete_row } = $$props;
  let { on_delete_col } = $$props;
  let { can_delete_rows } = $$props;
  let { can_delete_cols } = $$props;
  let { i18n } = $$props;
  let menu_element;
  onMount(() => {
    position_menu();
  });
  function position_menu() {
    if (!menu_element)
      return;
    const viewport_width = window.innerWidth;
    const viewport_height = window.innerHeight;
    const menu_rect = menu_element.getBoundingClientRect();
    let new_x = x - 30;
    let new_y = y - 20;
    if (new_x + menu_rect.width > viewport_width) {
      new_x = x - menu_rect.width + 10;
    }
    if (new_y + menu_rect.height > viewport_height) {
      new_y = y - menu_rect.height + 10;
    }
    $$invalidate(9, menu_element.style.left = `${new_x}px`, menu_element);
    $$invalidate(9, menu_element.style.top = `${new_y}px`, menu_element);
  }
  const click_handler = () => on_add_row_above();
  const click_handler_1 = () => on_add_row_below();
  const click_handler_2 = () => on_add_column_left();
  const click_handler_3 = () => on_add_column_right();
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menu_element = $$value;
      $$invalidate(9, menu_element);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(13, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(14, y = $$props2.y);
    if ("on_add_row_above" in $$props2)
      $$invalidate(0, on_add_row_above = $$props2.on_add_row_above);
    if ("on_add_row_below" in $$props2)
      $$invalidate(1, on_add_row_below = $$props2.on_add_row_below);
    if ("on_add_column_left" in $$props2)
      $$invalidate(2, on_add_column_left = $$props2.on_add_column_left);
    if ("on_add_column_right" in $$props2)
      $$invalidate(3, on_add_column_right = $$props2.on_add_column_right);
    if ("row" in $$props2)
      $$invalidate(15, row = $$props2.row);
    if ("col_count" in $$props2)
      $$invalidate(16, col_count = $$props2.col_count);
    if ("row_count" in $$props2)
      $$invalidate(17, row_count = $$props2.row_count);
    if ("on_delete_row" in $$props2)
      $$invalidate(4, on_delete_row = $$props2.on_delete_row);
    if ("on_delete_col" in $$props2)
      $$invalidate(5, on_delete_col = $$props2.on_delete_col);
    if ("can_delete_rows" in $$props2)
      $$invalidate(6, can_delete_rows = $$props2.can_delete_rows);
    if ("can_delete_cols" in $$props2)
      $$invalidate(7, can_delete_cols = $$props2.can_delete_cols);
    if ("i18n" in $$props2)
      $$invalidate(8, i18n = $$props2.i18n);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*row*/
    32768) {
      $$invalidate(12, is_header = row === -1);
    }
    if ($$self.$$.dirty & /*row_count*/
    131072) {
      $$invalidate(11, can_add_rows = row_count[1] === "dynamic");
    }
    if ($$self.$$.dirty & /*col_count*/
    65536) {
      $$invalidate(10, can_add_columns = col_count[1] === "dynamic");
    }
  };
  return [
    on_add_row_above,
    on_add_row_below,
    on_add_column_left,
    on_add_column_right,
    on_delete_row,
    on_delete_col,
    can_delete_rows,
    can_delete_cols,
    i18n,
    menu_element,
    can_add_columns,
    can_add_rows,
    is_header,
    x,
    y,
    row,
    col_count,
    row_count,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    div_binding
  ];
}
class CellMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
      x: 13,
      y: 14,
      on_add_row_above: 0,
      on_add_row_below: 1,
      on_add_column_left: 2,
      on_add_column_right: 3,
      row: 15,
      col_count: 16,
      row_count: 17,
      on_delete_row: 4,
      on_delete_col: 5,
      can_delete_rows: 6,
      can_delete_cols: 7,
      i18n: 8
    });
  }
}
function create_fragment$4(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, fill: true, xmlns: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M4 4h16v2.67l-6.67 6.67v8L9.33 19v-5.66L2.67 6.67V4h1.33z");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance$4($$self) {
  return [];
}
class FilterIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
  }
}
function create_if_block_4$1(ctx) {
  let div;
  let input;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*current_search_query*/
    ctx[0] && /*show_search*/
    ctx[3] === "filter" && create_if_block_5$1(ctx)
  );
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        placeholder: true,
        class: true
      });
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "text");
      attr(input, "placeholder", "Search...");
      attr(input, "class", "search-input svelte-b1nr0g");
      attr(div, "class", "search-container svelte-b1nr0g");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, input);
      set_input_value(
        input,
        /*current_search_query*/
        ctx[0]
      );
      append_hydration(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*current_search_query*/
      1 && input.value !== /*current_search_query*/
      ctx2[0]) {
        set_input_value(
          input,
          /*current_search_query*/
          ctx2[0]
        );
      }
      if (
        /*current_search_query*/
        ctx2[0] && /*show_search*/
        ctx2[3] === "filter"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*current_search_query, show_search*/
          9) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$1(ctx) {
  let button;
  let filtericon;
  let current;
  let mounted;
  let dispose;
  filtericon = new FilterIcon({});
  return {
    c() {
      button = element("button");
      create_component(filtericon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_nodes = children(button);
      claim_component(filtericon.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "toolbar-button check-button svelte-b1nr0g");
      attr(button, "aria-label", "Apply filter and update dataframe values");
      attr(button, "title", "Apply filter and update dataframe values");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      mount_component(filtericon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*on_commit_filter*/
            ctx[5]
          ))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(filtericon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filtericon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(filtericon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$1(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_aria_label_value;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_3$1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "toolbar-button svelte-b1nr0g");
      attr(button, "aria-label", button_aria_label_value = /*copied*/
      ctx[6] ? "Copied to clipboard" : "Copy table data");
      attr(button, "title", button_title_value = /*copied*/
      ctx[6] ? "Copied to clipboard" : "Copy table data");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handle_copy*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*copied*/
      64 && button_aria_label_value !== (button_aria_label_value = /*copied*/
      ctx2[6] ? "Copied to clipboard" : "Copy table data")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (!current || dirty & /*copied*/
      64 && button_title_value !== (button_title_value = /*copied*/
      ctx2[6] ? "Copied to clipboard" : "Copy table data")) {
        attr(button, "title", button_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let copy;
  let current;
  copy = new Copy({});
  return {
    c() {
      create_component(copy.$$.fragment);
    },
    l(nodes) {
      claim_component(copy.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(copy, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(copy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(copy, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let filtericon;
  let current;
  filtericon = new FilterIcon({});
  return {
    c() {
      create_component(filtericon.$$.fragment);
    },
    l(nodes) {
      claim_component(filtericon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(filtericon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(filtericon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filtericon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filtericon, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_aria_label_value;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$1, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*is_fullscreen*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "toolbar-button svelte-b1nr0g");
      attr(button, "aria-label", button_aria_label_value = /*is_fullscreen*/
      ctx[4] ? "Exit fullscreen" : "Enter fullscreen");
      attr(button, "title", button_title_value = /*is_fullscreen*/
      ctx[4] ? "Exit fullscreen" : "Enter fullscreen");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*is_fullscreen*/
      16 && button_aria_label_value !== (button_aria_label_value = /*is_fullscreen*/
      ctx2[4] ? "Exit fullscreen" : "Enter fullscreen")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (!current || dirty & /*is_fullscreen*/
      16 && button_title_value !== (button_title_value = /*is_fullscreen*/
      ctx2[4] ? "Exit fullscreen" : "Enter fullscreen")) {
        attr(button, "title", button_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block(ctx) {
  let maximize;
  let current;
  maximize = new Maximize({});
  return {
    c() {
      create_component(maximize.$$.fragment);
    },
    l(nodes) {
      claim_component(maximize.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(maximize, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(maximize.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(maximize.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(maximize, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let minimize;
  let current;
  minimize = new Minimize({});
  return {
    c() {
      create_component(minimize.$$.fragment);
    },
    l(nodes) {
      claim_component(minimize.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(minimize, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(minimize.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(minimize.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(minimize, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*show_search*/
    ctx[3] !== "none" && create_if_block_4$1(ctx)
  );
  let if_block1 = (
    /*show_copy_button*/
    ctx[2] && create_if_block_2$1(ctx)
  );
  let if_block2 = (
    /*show_fullscreen_button*/
    ctx[1] && create_if_block$1(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "toolbar-buttons svelte-b1nr0g");
      attr(div1, "class", "toolbar svelte-b1nr0g");
      attr(div1, "role", "toolbar");
      attr(div1, "aria-label", "Table actions");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*show_search*/
        ctx2[3] !== "none"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*show_search*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*show_copy_button*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*show_copy_button*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*show_fullscreen_button*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*show_fullscreen_button*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { show_fullscreen_button = false } = $$props;
  let { show_copy_button = false } = $$props;
  let { show_search = "none" } = $$props;
  let { is_fullscreen = false } = $$props;
  let { on_copy } = $$props;
  let { on_commit_filter } = $$props;
  const dispatch = createEventDispatcher();
  let copied = false;
  let timer;
  let { current_search_query = null } = $$props;
  function copy_feedback() {
    $$invalidate(6, copied = true);
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(
      () => {
        $$invalidate(6, copied = false);
      },
      2e3
    );
  }
  async function handle_copy() {
    await on_copy();
    copy_feedback();
  }
  onDestroy(() => {
    if (timer)
      clearTimeout(timer);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    current_search_query = this.value;
    $$invalidate(0, current_search_query);
  }
  $$self.$$set = ($$props2) => {
    if ("show_fullscreen_button" in $$props2)
      $$invalidate(1, show_fullscreen_button = $$props2.show_fullscreen_button);
    if ("show_copy_button" in $$props2)
      $$invalidate(2, show_copy_button = $$props2.show_copy_button);
    if ("show_search" in $$props2)
      $$invalidate(3, show_search = $$props2.show_search);
    if ("is_fullscreen" in $$props2)
      $$invalidate(4, is_fullscreen = $$props2.is_fullscreen);
    if ("on_copy" in $$props2)
      $$invalidate(8, on_copy = $$props2.on_copy);
    if ("on_commit_filter" in $$props2)
      $$invalidate(5, on_commit_filter = $$props2.on_commit_filter);
    if ("current_search_query" in $$props2)
      $$invalidate(0, current_search_query = $$props2.current_search_query);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*current_search_query*/
    1) {
      dispatch("search", current_search_query);
    }
  };
  return [
    current_search_query,
    show_fullscreen_button,
    show_copy_button,
    show_search,
    is_fullscreen,
    on_commit_filter,
    copied,
    handle_copy,
    on_copy,
    click_handler,
    input_input_handler
  ];
}
class Toolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {
      show_fullscreen_button: 1,
      show_copy_button: 2,
      show_search: 3,
      is_fullscreen: 4,
      on_copy: 8,
      on_commit_filter: 5,
      current_search_query: 0
    });
  }
}
function create_fragment$2(ctx) {
  let div;
  let button0;
  let svg0;
  let path0;
  let button0_aria_label_value;
  let button0_aria_pressed_value;
  let t;
  let button1;
  let svg1;
  let path1;
  let button1_aria_label_value;
  let button1_aria_pressed_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true
      });
      var div_nodes = children(div);
      button0 = claim_element(div_nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        "aria-pressed": true
      });
      var button0_nodes = children(button0);
      svg0 = claim_svg_element(button0_nodes, "svg", {
        viewBox: true,
        fill: true,
        xmlns: true,
        "aria-hidden": true,
        focusable: true,
        class: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(path0).forEach(detach);
      svg0_nodes.forEach(detach);
      button0_nodes.forEach(detach);
      t = claim_space(div_nodes);
      button1 = claim_element(div_nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        "aria-pressed": true
      });
      var button1_nodes = children(button1);
      svg1 = claim_svg_element(button1_nodes, "svg", {
        viewBox: true,
        fill: true,
        xmlns: true,
        "aria-hidden": true,
        focusable: true,
        class: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", {
        d: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true
      });
      children(path1).forEach(detach);
      svg1_nodes.forEach(detach);
      button1_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path0, "d", "M7 14l5-5 5 5");
      attr(path0, "stroke", "currentColor");
      attr(path0, "stroke-width", "2");
      attr(path0, "stroke-linecap", "round");
      attr(path0, "stroke-linejoin", "round");
      attr(svg0, "viewBox", "0 0 24 24");
      attr(svg0, "fill", "none");
      attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg0, "aria-hidden", "true");
      attr(svg0, "focusable", "false");
      attr(svg0, "class", "svelte-a5uqm5");
      attr(button0, "class", "sort-button up svelte-a5uqm5");
      attr(button0, "aria-label", button0_aria_label_value = /*i18n*/
      ctx[1]("dataframe.sort_ascending"));
      attr(button0, "aria-pressed", button0_aria_pressed_value = /*direction*/
      ctx[0] === "asc");
      toggle_class(
        button0,
        "active",
        /*direction*/
        ctx[0] === "asc"
      );
      attr(path1, "d", "M7 10l5 5 5-5");
      attr(path1, "stroke", "currentColor");
      attr(path1, "stroke-width", "2");
      attr(path1, "stroke-linecap", "round");
      attr(path1, "stroke-linejoin", "round");
      attr(svg1, "viewBox", "0 0 24 24");
      attr(svg1, "fill", "none");
      attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg1, "aria-hidden", "true");
      attr(svg1, "focusable", "false");
      attr(svg1, "class", "svelte-a5uqm5");
      attr(button1, "class", "sort-button down svelte-a5uqm5");
      attr(button1, "aria-label", button1_aria_label_value = /*i18n*/
      ctx[1]("dataframe.sort_descending"));
      attr(button1, "aria-pressed", button1_aria_pressed_value = /*direction*/
      ctx[0] === "des");
      toggle_class(
        button1,
        "active",
        /*direction*/
        ctx[0] === "des"
      );
      attr(div, "class", "sort-icons svelte-a5uqm5");
      attr(div, "role", "group");
      attr(div, "aria-label", div_aria_label_value = /*i18n*/
      ctx[1]("dataframe.sort_column"));
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, button0);
      append_hydration(button0, svg0);
      append_hydration(svg0, path0);
      append_hydration(div, t);
      append_hydration(div, button1);
      append_hydration(button1, svg1);
      append_hydration(svg1, path1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[3]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*i18n*/
      2 && button0_aria_label_value !== (button0_aria_label_value = /*i18n*/
      ctx2[1]("dataframe.sort_ascending"))) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if (dirty & /*direction*/
      1 && button0_aria_pressed_value !== (button0_aria_pressed_value = /*direction*/
      ctx2[0] === "asc")) {
        attr(button0, "aria-pressed", button0_aria_pressed_value);
      }
      if (dirty & /*direction*/
      1) {
        toggle_class(
          button0,
          "active",
          /*direction*/
          ctx2[0] === "asc"
        );
      }
      if (dirty & /*i18n*/
      2 && button1_aria_label_value !== (button1_aria_label_value = /*i18n*/
      ctx2[1]("dataframe.sort_descending"))) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
      if (dirty & /*direction*/
      1 && button1_aria_pressed_value !== (button1_aria_pressed_value = /*direction*/
      ctx2[0] === "des")) {
        attr(button1, "aria-pressed", button1_aria_pressed_value);
      }
      if (dirty & /*direction*/
      1) {
        toggle_class(
          button1,
          "active",
          /*direction*/
          ctx2[0] === "des"
        );
      }
      if (dirty & /*i18n*/
      2 && div_aria_label_value !== (div_aria_label_value = /*i18n*/
      ctx2[1]("dataframe.sort_column"))) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { direction = null } = $$props;
  let { i18n } = $$props;
  const dispatch = createEventDispatcher();
  const click_handler = () => dispatch("sort", "asc");
  const click_handler_1 = () => dispatch("sort", "des");
  $$self.$$set = ($$props2) => {
    if ("direction" in $$props2)
      $$invalidate(0, direction = $$props2.direction);
    if ("i18n" in $$props2)
      $$invalidate(1, i18n = $$props2.i18n);
  };
  return [direction, i18n, dispatch, click_handler, click_handler_1];
}
class SortIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { direction: 0, i18n: 1 });
  }
}
function is_cell_selected(cell, selected_cells) {
  const [row, col] = cell;
  if (!selected_cells.some(([r, c]) => r === row && c === col))
    return "";
  const up = selected_cells.some(([r, c]) => r === row - 1 && c === col);
  const down = selected_cells.some(([r, c]) => r === row + 1 && c === col);
  const left = selected_cells.some(([r, c]) => r === row && c === col - 1);
  const right = selected_cells.some(([r, c]) => r === row && c === col + 1);
  return `cell-selected${up ? " no-top" : ""}${down ? " no-bottom" : ""}${left ? " no-left" : ""}${right ? " no-right" : ""}`;
}
function get_range_selection(start, end) {
  const [start_row, start_col] = start;
  const [end_row, end_col] = end;
  const min_row = Math.min(start_row, end_row);
  const max_row = Math.max(start_row, end_row);
  const min_col = Math.min(start_col, end_col);
  const max_col = Math.max(start_col, end_col);
  const cells = [];
  for (let i = min_row; i <= max_row; i++) {
    for (let j = min_col; j <= max_col; j++) {
      cells.push([i, j]);
    }
  }
  return cells;
}
function handle_selection(current, selected_cells, event) {
  if (event.shiftKey && selected_cells.length > 0) {
    return get_range_selection(
      selected_cells[selected_cells.length - 1],
      current
    );
  }
  if (event.metaKey || event.ctrlKey) {
    const is_cell_match = ([r, c]) => r === current[0] && c === current[1];
    const index = selected_cells.findIndex(is_cell_match);
    return index === -1 ? [...selected_cells, current] : selected_cells.filter((_, i) => i !== index);
  }
  return [current];
}
function handle_delete_key(data, selected_cells) {
  const new_data = data.map((row) => [...row]);
  selected_cells.forEach(([row, col]) => {
    if (new_data[row] && new_data[row][col]) {
      new_data[row][col] = { ...new_data[row][col], value: "" };
    }
  });
  return new_data;
}
function should_show_cell_menu(cell, selected_cells, editable) {
  const [row, col] = cell;
  return editable && selected_cells.length === 1 && selected_cells[0][0] === row && selected_cells[0][1] === col;
}
function get_next_cell_coordinates(current, data, shift_key) {
  var _a, _b, _c;
  const [row, col] = current;
  const direction = shift_key ? -1 : 1;
  if ((_a = data[row]) == null ? void 0 : _a[col + direction]) {
    return [row, col + direction];
  }
  const next_row = row + (direction > 0 ? 1 : 0);
  const prev_row = row + (direction < 0 ? -1 : 0);
  if (direction > 0 && ((_b = data[next_row]) == null ? void 0 : _b[0])) {
    return [next_row, 0];
  }
  if (direction < 0 && ((_c = data[prev_row]) == null ? void 0 : _c[data[0].length - 1])) {
    return [prev_row, data[0].length - 1];
  }
  return false;
}
function move_cursor(key, current_coords, data) {
  var _a;
  const dir = {
    ArrowRight: [0, 1],
    ArrowLeft: [0, -1],
    ArrowDown: [1, 0],
    ArrowUp: [-1, 0]
  }[key];
  const i = current_coords[0] + dir[0];
  const j = current_coords[1] + dir[1];
  if (i < 0 && j <= 0) {
    return false;
  }
  const is_data = (_a = data[i]) == null ? void 0 : _a[j];
  if (is_data) {
    return [i, j];
  }
  return false;
}
function get_current_indices(id, data) {
  return data.reduce(
    (acc, arr, i) => {
      const j = arr.reduce(
        (_acc, _data, k) => id === _data.id ? k : _acc,
        -1
      );
      return j === -1 ? acc : [i, j];
    },
    [-1, -1]
  );
}
function handle_click_outside(event, parent) {
  const [trigger] = event.composedPath();
  return !parent.contains(trigger);
}
function select_column(data, col) {
  return Array.from({ length: data.length }, (_, i) => [i, col]);
}
function select_row(data, row) {
  return Array.from({ length: data[0].length }, (_, i) => [row, i]);
}
function calculate_selection_positions(selected, data, els, parent, table) {
  var _a, _b;
  const [row, col] = selected;
  if (!((_a = data[row]) == null ? void 0 : _a[col])) {
    return { col_pos: "0px", row_pos: void 0 };
  }
  let offset = 0;
  for (let i = 0; i < col; i++) {
    offset += parseFloat(
      getComputedStyle(parent).getPropertyValue(`--cell-width-${i}`)
    );
  }
  const cell_id = data[row][col].id;
  const cell_el = (_b = els[cell_id]) == null ? void 0 : _b.cell;
  if (!cell_el) {
    return { col_pos: "0px", row_pos: void 0 };
  }
  const cell_rect = cell_el.getBoundingClientRect();
  const table_rect = table.getBoundingClientRect();
  const col_pos = `${cell_rect.left - table_rect.left + cell_rect.width / 2}px`;
  const relative_top = cell_rect.top - table_rect.top;
  const row_pos = `${relative_top + cell_rect.height / 2}px`;
  return { col_pos, row_pos };
}
function sort_data(data, sort_by, sort_direction) {
  if (!data || !data.length || !data[0]) {
    return [];
  }
  if (typeof sort_by === "number" && sort_direction && sort_by >= 0 && sort_by < data[0].length) {
    const row_indices = [...Array(data.length)].map((_, i) => i);
    row_indices.sort((row_a_idx, row_b_idx) => {
      const row_a = data[row_a_idx];
      const row_b = data[row_b_idx];
      if (!row_a || !row_b || sort_by >= row_a.length || sort_by >= row_b.length)
        return 0;
      const val_a = row_a[sort_by].value;
      const val_b = row_b[sort_by].value;
      const comparison = val_a < val_b ? -1 : val_a > val_b ? 1 : 0;
      return sort_direction === "asc" ? comparison : -comparison;
    });
    return row_indices;
  }
  return [...Array(data.length)].map((_, i) => i);
}
function get_max(data) {
  if (!data || !data.length)
    return [];
  let max = data[0].slice();
  for (let i = 0; i < data.length; i++) {
    for (let j = 0; j < data[i].length; j++) {
      if (`${max[j].value}`.length < `${data[i][j].value}`.length) {
        max[j] = data[i][j];
      }
    }
  }
  return max;
}
function sort_table_data(data, display_value, styling, col, dir) {
  const indices = sort_data(data, col, dir);
  const new_data = indices.map((i) => data[i]);
  data.splice(0, data.length, ...new_data);
  if (display_value) {
    const new_display = indices.map((i) => display_value[i]);
    display_value.splice(0, display_value.length, ...new_display);
  }
  if (styling) {
    const new_styling = indices.map((i) => styling[i]);
    styling.splice(0, styling.length, ...new_styling);
  }
}
async function copy_table_data(data, selected_cells) {
  const csv = selected_cells.reduce(
    (acc, [row, col]) => {
      acc[row] = acc[row] || {};
      const value = String(data[row][col].value);
      acc[row][col] = value.includes(",") || value.includes('"') || value.includes("\n") ? `"${value.replace(/"/g, '""')}"` : value;
      return acc;
    },
    {}
  );
  const rows = Object.keys(csv).sort((a, b) => +a - +b);
  const cols = Object.keys(csv[rows[0]]).sort((a, b) => +a - +b);
  const text2 = rows.map((r) => cols.map((c) => csv[r][c] || "").join(",")).join("\n");
  try {
    await navigator.clipboard.writeText(text2);
  } catch (err) {
    console.error("Copy failed:", err);
    throw new Error("Failed to copy to clipboard: " + err.message);
  }
}
function guess_delimiter(text2, possibleDelimiters) {
  return possibleDelimiters.filter(weedOut);
  function weedOut(delimiter) {
    var cache = -1;
    return text2.split("\n").every(checkLength);
    function checkLength(line) {
      if (!line)
        return true;
      var length = line.split(delimiter).length;
      if (cache < 0)
        cache = length;
      return cache === length && length > 1;
    }
  }
}
function data_uri_to_blob(data_uri) {
  const byte_str = atob(data_uri.split(",")[1]);
  const mime_str = data_uri.split(",")[0].split(":")[1].split(";")[0];
  const ab = new ArrayBuffer(byte_str.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byte_str.length; i++) {
    ia[i] = byte_str.charCodeAt(i);
  }
  return new Blob([ab], { type: mime_str });
}
function handle_file_upload(data_uri, update_headers, update_values) {
  const blob = data_uri_to_blob(data_uri);
  const reader = new FileReader();
  reader.addEventListener("loadend", (e) => {
    var _a;
    if (!((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.result) || typeof e.target.result !== "string")
      return;
    const [delimiter] = guess_delimiter(e.target.result, [",", "	"]);
    const [head, ...rest] = dsvFormat(delimiter).parseRows(e.target.result);
    update_headers(head);
    update_values(rest);
  });
  reader.readAsText(blob);
}
const { window: window_1 } = globals;
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[139] = list[i].value;
  child_ctx[140] = list[i].id;
  child_ctx[143] = list;
  child_ctx[144] = i;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[139] = list[i].value;
  child_ctx[140] = list[i].id;
  child_ctx[141] = list;
  child_ctx[142] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[139] = list[i].value;
  child_ctx[140] = list[i].id;
  child_ctx[145] = list;
  child_ctx[142] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[139] = list[i].value;
  child_ctx[140] = list[i].id;
  child_ctx[144] = i;
  return child_ctx;
}
function create_if_block_10(ctx) {
  let div;
  let p;
  let t;
  return {
    c() {
      div = element("div");
      p = element("p");
      t = text(
        /*label*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      p = claim_element(div_nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*label*/
        ctx[2]
      );
      p_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "svelte-m6pdii");
      attr(div, "class", "label svelte-m6pdii");
    },
    m(target, anchor) {
      insert_hydration(target, div, anchor);
      append_hydration(div, p);
      append_hydration(p, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      4)
        set_data(
          t,
          /*label*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_9(ctx) {
  let button0;
  let textContent = "⋮";
  let t1;
  let button1;
  let textContent_1 = "⋮";
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      this.h();
    },
    l(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-1sqo8ds")
        button0.textContent = textContent;
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-mm502l")
        button1.textContent = textContent_1;
      this.h();
    },
    h() {
      attr(button0, "class", "selection-button selection-button-column svelte-m6pdii");
      attr(button0, "aria-label", "Select column");
      attr(button1, "class", "selection-button selection-button-row svelte-m6pdii");
      attr(button1, "aria-label", "Select row");
    },
    m(target, anchor) {
      insert_hydration(target, button0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(button0, "click", stop_propagation(
            /*click_handler*/
            ctx[78]
          )),
          listen(button1, "click", stop_propagation(
            /*click_handler_1*/
            ctx[79]
          ))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_8(ctx) {
  let caption;
  let t;
  return {
    c() {
      caption = element("caption");
      t = text(
        /*label*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      caption = claim_element(nodes, "CAPTION", { class: true });
      var caption_nodes = children(caption);
      t = claim_text(
        caption_nodes,
        /*label*/
        ctx[2]
      );
      caption_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(caption, "class", "sr-only");
    },
    m(target, anchor) {
      insert_hydration(target, caption, anchor);
      append_hydration(caption, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      4)
        set_data(
          t,
          /*label*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(caption);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let th;
  let textContent = `<div class="cell-wrap svelte-m6pdii"><div class="header-content svelte-m6pdii"><div class="header-text"></div></div></div>`;
  return {
    c() {
      th = element("th");
      th.innerHTML = textContent;
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", {
        class: true,
        style: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(th) !== "svelte-16yee2u")
        th.innerHTML = textContent;
      this.h();
    },
    h() {
      attr(th, "class", "row-number-header frozen-column always-frozen svelte-m6pdii");
      set_style(th, "left", "0");
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
function create_each_block_3(key_1, ctx) {
  let th;
  let div2;
  let div1;
  let editablecell;
  let t0;
  let div0;
  let sorticon;
  let t1;
  let th_aria_sort_value;
  let current;
  editablecell = new EditableCell({
    props: {
      value: (
        /*value*/
        ctx[139]
      ),
      latex_delimiters: (
        /*latex_delimiters*/
        ctx[6]
      ),
      line_breaks: (
        /*line_breaks*/
        ctx[12]
      ),
      header: true,
      edit: false,
      el: null,
      root: (
        /*root*/
        ctx[9]
      ),
      editable: (
        /*editable*/
        ctx[7]
      )
    }
  });
  function sort_handler(...args) {
    return (
      /*sort_handler*/
      ctx[80](
        /*i*/
        ctx[144],
        ...args
      )
    );
  }
  sorticon = new SortIcon({
    props: {
      direction: (
        /*sort_by*/
        ctx[29] === /*i*/
        ctx[144] ? (
          /*sort_direction*/
          ctx[28]
        ) : null
      ),
      i18n: (
        /*i18n*/
        ctx[10]
      )
    }
  });
  sorticon.$on("sort", sort_handler);
  return {
    key: key_1,
    first: null,
    c() {
      th = element("th");
      div2 = element("div");
      div1 = element("div");
      create_component(editablecell.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(sorticon.$$.fragment);
      t1 = space();
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", {
        "aria-sort": true,
        style: true,
        class: true
      });
      var th_nodes = children(th);
      div2 = claim_element(th_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(editablecell.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(sorticon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      t1 = claim_space(th_nodes);
      th_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "sort-buttons svelte-m6pdii");
      attr(div1, "class", "header-content svelte-m6pdii");
      attr(div2, "class", "cell-wrap svelte-m6pdii");
      attr(th, "aria-sort", th_aria_sort_value = /*get_sort_status*/
      ctx[50](
        /*value*/
        ctx[139],
        /*sort_by*/
        ctx[29],
        /*sort_direction*/
        ctx[28]
      ));
      set_style(
        th,
        "width",
        /*column_widths*/
        ctx[13].length ? (
          /*column_widths*/
          ctx[13][
            /*i*/
            ctx[144]
          ]
        ) : void 0
      );
      set_style(
        th,
        "left",
        /*i*/
        ctx[144] < /*actual_pinned_columns*/
        ctx[33] ? (
          /*i*/
          ctx[144] === 0 ? (
            /*show_row_numbers*/
            ctx[14] ? "var(--cell-width-row-number)" : "0"
          ) : `calc(${/*show_row_numbers*/
          ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
            /*i*/
            ctx[144]
          ).fill(0).map(func).join(" + ")})`
        ) : "auto"
      );
      attr(th, "class", "svelte-m6pdii");
      toggle_class(
        th,
        "frozen-column",
        /*i*/
        ctx[144] < /*actual_pinned_columns*/
        ctx[33]
      );
      toggle_class(
        th,
        "last-frozen",
        /*show_row_numbers*/
        ctx[14] ? (
          /*i*/
          ctx[144] === /*actual_pinned_columns*/
          ctx[33] - 1
        ) : (
          /*i*/
          ctx[144] === /*actual_pinned_columns*/
          ctx[33] - 1
        )
      );
      toggle_class(
        th,
        "editing",
        /*header_edit*/
        ctx[37] === /*i*/
        ctx[144]
      );
      this.first = th;
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
      append_hydration(th, div2);
      append_hydration(div2, div1);
      mount_component(editablecell, div1, null);
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      mount_component(sorticon, div0, null);
      append_hydration(th, t1);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const editablecell_changes = {};
      if (dirty[0] & /*_headers*/
      67108864)
        editablecell_changes.value = /*value*/
        ctx[139];
      if (dirty[0] & /*latex_delimiters*/
      64)
        editablecell_changes.latex_delimiters = /*latex_delimiters*/
        ctx[6];
      if (dirty[0] & /*line_breaks*/
      4096)
        editablecell_changes.line_breaks = /*line_breaks*/
        ctx[12];
      if (dirty[0] & /*root*/
      512)
        editablecell_changes.root = /*root*/
        ctx[9];
      if (dirty[0] & /*editable*/
      128)
        editablecell_changes.editable = /*editable*/
        ctx[7];
      editablecell.$set(editablecell_changes);
      const sorticon_changes = {};
      if (dirty[0] & /*sort_by, _headers, sort_direction*/
      872415232)
        sorticon_changes.direction = /*sort_by*/
        ctx[29] === /*i*/
        ctx[144] ? (
          /*sort_direction*/
          ctx[28]
        ) : null;
      if (dirty[0] & /*i18n*/
      1024)
        sorticon_changes.i18n = /*i18n*/
        ctx[10];
      sorticon.$set(sorticon_changes);
      if (!current || dirty[0] & /*_headers, sort_by, sort_direction*/
      872415232 && th_aria_sort_value !== (th_aria_sort_value = /*get_sort_status*/
      ctx[50](
        /*value*/
        ctx[139],
        /*sort_by*/
        ctx[29],
        /*sort_direction*/
        ctx[28]
      ))) {
        attr(th, "aria-sort", th_aria_sort_value);
      }
      if (!current || dirty[0] & /*column_widths, _headers*/
      67117056) {
        set_style(
          th,
          "width",
          /*column_widths*/
          ctx[13].length ? (
            /*column_widths*/
            ctx[13][
              /*i*/
              ctx[144]
            ]
          ) : void 0
        );
      }
      if (!current || dirty[0] & /*_headers, show_row_numbers*/
      67125248 | dirty[1] & /*actual_pinned_columns*/
      4) {
        set_style(
          th,
          "left",
          /*i*/
          ctx[144] < /*actual_pinned_columns*/
          ctx[33] ? (
            /*i*/
            ctx[144] === 0 ? (
              /*show_row_numbers*/
              ctx[14] ? "var(--cell-width-row-number)" : "0"
            ) : `calc(${/*show_row_numbers*/
            ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
              /*i*/
              ctx[144]
            ).fill(0).map(func).join(" + ")})`
          ) : "auto"
        );
      }
      if (!current || dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*actual_pinned_columns*/
      4) {
        toggle_class(
          th,
          "frozen-column",
          /*i*/
          ctx[144] < /*actual_pinned_columns*/
          ctx[33]
        );
      }
      if (!current || dirty[0] & /*show_row_numbers, _headers*/
      67125248 | dirty[1] & /*actual_pinned_columns*/
      4) {
        toggle_class(
          th,
          "last-frozen",
          /*show_row_numbers*/
          ctx[14] ? (
            /*i*/
            ctx[144] === /*actual_pinned_columns*/
            ctx[33] - 1
          ) : (
            /*i*/
            ctx[144] === /*actual_pinned_columns*/
            ctx[33] - 1
          )
        );
      }
      if (!current || dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*header_edit*/
      64) {
        toggle_class(
          th,
          "editing",
          /*header_edit*/
          ctx[37] === /*i*/
          ctx[144]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablecell.$$.fragment, local);
      transition_in(sorticon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editablecell.$$.fragment, local);
      transition_out(sorticon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      destroy_component(editablecell);
      destroy_component(sorticon);
    }
  };
}
function create_each_block_2(key_1, ctx) {
  let td;
  let div;
  let editablecell;
  let t;
  let j = (
    /*j*/
    ctx[142]
  );
  let current;
  editablecell = new EditableCell({
    props: {
      value: (
        /*value*/
        ctx[139]
      ),
      latex_delimiters: (
        /*latex_delimiters*/
        ctx[6]
      ),
      line_breaks: (
        /*line_breaks*/
        ctx[12]
      ),
      datatype: Array.isArray(
        /*datatype*/
        ctx[1]
      ) ? (
        /*datatype*/
        ctx[1][
          /*j*/
          ctx[142]
        ]
      ) : (
        /*datatype*/
        ctx[1]
      ),
      edit: false,
      el: null,
      root: (
        /*root*/
        ctx[9]
      ),
      editable: (
        /*editable*/
        ctx[7]
      )
    }
  });
  const assign_td = () => (
    /*td_binding*/
    ctx[81](td, j)
  );
  const unassign_td = () => (
    /*td_binding*/
    ctx[81](null, j)
  );
  return {
    key: key_1,
    first: null,
    c() {
      td = element("td");
      div = element("div");
      create_component(editablecell.$$.fragment);
      t = space();
      this.h();
    },
    l(nodes) {
      td = claim_element(nodes, "TD", { tabindex: true, class: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(editablecell.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      t = claim_space(td_nodes);
      td_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "cell-wrap svelte-m6pdii");
      attr(td, "tabindex", "-1");
      attr(td, "class", "svelte-m6pdii");
      this.first = td;
    },
    m(target, anchor) {
      insert_hydration(target, td, anchor);
      append_hydration(td, div);
      mount_component(editablecell, div, null);
      append_hydration(td, t);
      assign_td();
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const editablecell_changes = {};
      if (dirty[1] & /*max*/
      262144)
        editablecell_changes.value = /*value*/
        ctx[139];
      if (dirty[0] & /*latex_delimiters*/
      64)
        editablecell_changes.latex_delimiters = /*latex_delimiters*/
        ctx[6];
      if (dirty[0] & /*line_breaks*/
      4096)
        editablecell_changes.line_breaks = /*line_breaks*/
        ctx[12];
      if (dirty[0] & /*datatype*/
      2 | dirty[1] & /*max*/
      262144)
        editablecell_changes.datatype = Array.isArray(
          /*datatype*/
          ctx[1]
        ) ? (
          /*datatype*/
          ctx[1][
            /*j*/
            ctx[142]
          ]
        ) : (
          /*datatype*/
          ctx[1]
        );
      if (dirty[0] & /*root*/
      512)
        editablecell_changes.root = /*root*/
        ctx[9];
      if (dirty[0] & /*editable*/
      128)
        editablecell_changes.editable = /*editable*/
        ctx[7];
      editablecell.$set(editablecell_changes);
      if (j !== /*j*/
      ctx[142]) {
        unassign_td();
        j = /*j*/
        ctx[142];
        assign_td();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      destroy_component(editablecell);
      unassign_td();
    }
  };
}
function create_if_block_6(ctx) {
  let caption;
  let t;
  return {
    c() {
      caption = element("caption");
      t = text(
        /*label*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      caption = claim_element(nodes, "CAPTION", { class: true });
      var caption_nodes = children(caption);
      t = claim_text(
        caption_nodes,
        /*label*/
        ctx[2]
      );
      caption_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(caption, "class", "sr-only");
    },
    m(target, anchor) {
      insert_hydration(target, caption, anchor);
      append_hydration(caption, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*label*/
      4)
        set_data(
          t,
          /*label*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(caption);
      }
    }
  };
}
function create_default_slot_1(ctx) {
  let if_block_anchor;
  let if_block = (
    /*label*/
    ctx[2] && /*label*/
    ctx[2].length !== 0 && create_if_block_6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*label*/
        ctx2[2] && /*label*/
        ctx2[2].length !== 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let th;
  let textContent = `<div class="cell-wrap svelte-m6pdii"><div class="header-content svelte-m6pdii"><div class="header-text"></div></div></div>`;
  return {
    c() {
      th = element("th");
      th.innerHTML = textContent;
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", {
        class: true,
        style: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(th) !== "svelte-16yee2u")
        th.innerHTML = textContent;
      this.h();
    },
    h() {
      attr(th, "class", "row-number-header frozen-column always-frozen svelte-m6pdii");
      set_style(th, "left", "0");
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let button;
  let textContent = "⋮";
  let mounted;
  let dispose;
  function click_handler_4(...args) {
    return (
      /*click_handler_4*/
      ctx[96](
        /*i*/
        ctx[144],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-3v1qhb")
        button.textContent = textContent;
      this.h();
    },
    h() {
      attr(button, "class", "cell-menu-button svelte-m6pdii");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_4);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let th;
  let div2;
  let div1;
  let editablecell;
  let updating_value;
  let updating_el;
  let t0;
  let div0;
  let sorticon;
  let t1;
  let t2;
  let th_aria_sort_value;
  let current;
  let mounted;
  let dispose;
  function editablecell_value_binding_1(value) {
    ctx[92](
      value,
      /*i*/
      ctx[144]
    );
  }
  function editablecell_el_binding_1(value) {
    ctx[93](
      value,
      /*id*/
      ctx[140]
    );
  }
  function dblclick_handler() {
    return (
      /*dblclick_handler*/
      ctx[94](
        /*i*/
        ctx[144]
      )
    );
  }
  let editablecell_props = {
    max_chars: (
      /*max_chars*/
      ctx[19]
    ),
    latex_delimiters: (
      /*latex_delimiters*/
      ctx[6]
    ),
    line_breaks: (
      /*line_breaks*/
      ctx[12]
    ),
    edit: (
      /*header_edit*/
      ctx[37] === /*i*/
      ctx[144]
    ),
    header: true,
    root: (
      /*root*/
      ctx[9]
    ),
    editable: (
      /*editable*/
      ctx[7]
    )
  };
  if (
    /*_headers*/
    ctx[26][
      /*i*/
      ctx[144]
    ].value !== void 0
  ) {
    editablecell_props.value = /*_headers*/
    ctx[26][
      /*i*/
      ctx[144]
    ].value;
  }
  if (
    /*els*/
    ctx[25][
      /*id*/
      ctx[140]
    ].input !== void 0
  ) {
    editablecell_props.el = /*els*/
    ctx[25][
      /*id*/
      ctx[140]
    ].input;
  }
  editablecell = new EditableCell({ props: editablecell_props });
  binding_callbacks.push(() => bind(editablecell, "value", editablecell_value_binding_1));
  binding_callbacks.push(() => bind(editablecell, "el", editablecell_el_binding_1));
  editablecell.$on(
    "keydown",
    /*end_header_edit*/
    ctx[54]
  );
  editablecell.$on("dblclick", dblclick_handler);
  function sort_handler_1(...args) {
    return (
      /*sort_handler_1*/
      ctx[95](
        /*i*/
        ctx[144],
        ...args
      )
    );
  }
  sorticon = new SortIcon({
    props: {
      direction: (
        /*sort_by*/
        ctx[29] === /*i*/
        ctx[144] ? (
          /*sort_direction*/
          ctx[28]
        ) : null
      ),
      i18n: (
        /*i18n*/
        ctx[10]
      )
    }
  });
  sorticon.$on("sort", sort_handler_1);
  let if_block = (
    /*editable*/
    ctx[7] && create_if_block_4(ctx)
  );
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[97](
        /*i*/
        ctx[144]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      th = element("th");
      div2 = element("div");
      div1 = element("div");
      create_component(editablecell.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(sorticon.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", {
        "aria-sort": true,
        style: true,
        class: true
      });
      var th_nodes = children(th);
      div2 = claim_element(th_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(editablecell.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(sorticon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach);
      t2 = claim_space(th_nodes);
      th_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "sort-buttons svelte-m6pdii");
      attr(div1, "class", "header-content svelte-m6pdii");
      attr(div2, "class", "cell-wrap svelte-m6pdii");
      attr(th, "aria-sort", th_aria_sort_value = /*get_sort_status*/
      ctx[50](
        /*value*/
        ctx[139],
        /*sort_by*/
        ctx[29],
        /*sort_direction*/
        ctx[28]
      ));
      set_style(
        th,
        "width",
        /*get_cell_width*/
        ctx[56](
          /*i*/
          ctx[144]
        )
      );
      set_style(
        th,
        "left",
        /*i*/
        ctx[144] < /*actual_pinned_columns*/
        ctx[33] ? (
          /*i*/
          ctx[144] === 0 ? (
            /*show_row_numbers*/
            ctx[14] ? "var(--cell-width-row-number)" : "0"
          ) : `calc(${/*show_row_numbers*/
          ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
            /*i*/
            ctx[144]
          ).fill(0).map(func_2).join(" + ")})`
        ) : "auto"
      );
      attr(th, "class", "svelte-m6pdii");
      toggle_class(
        th,
        "frozen-column",
        /*i*/
        ctx[144] < /*actual_pinned_columns*/
        ctx[33]
      );
      toggle_class(
        th,
        "last-frozen",
        /*i*/
        ctx[144] === /*actual_pinned_columns*/
        ctx[33] - 1
      );
      toggle_class(
        th,
        "focus",
        /*header_edit*/
        ctx[37] === /*i*/
        ctx[144] || /*selected_header*/
        ctx[38] === /*i*/
        ctx[144]
      );
      this.first = th;
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
      append_hydration(th, div2);
      append_hydration(div2, div1);
      mount_component(editablecell, div1, null);
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      mount_component(sorticon, div0, null);
      append_hydration(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      append_hydration(th, t2);
      current = true;
      if (!mounted) {
        dispose = listen(th, "click", click_handler_5);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const editablecell_changes = {};
      if (dirty[0] & /*max_chars*/
      524288)
        editablecell_changes.max_chars = /*max_chars*/
        ctx[19];
      if (dirty[0] & /*latex_delimiters*/
      64)
        editablecell_changes.latex_delimiters = /*latex_delimiters*/
        ctx[6];
      if (dirty[0] & /*line_breaks*/
      4096)
        editablecell_changes.line_breaks = /*line_breaks*/
        ctx[12];
      if (dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*header_edit*/
      64)
        editablecell_changes.edit = /*header_edit*/
        ctx[37] === /*i*/
        ctx[144];
      if (dirty[0] & /*root*/
      512)
        editablecell_changes.root = /*root*/
        ctx[9];
      if (dirty[0] & /*editable*/
      128)
        editablecell_changes.editable = /*editable*/
        ctx[7];
      if (!updating_value && dirty[0] & /*_headers*/
      67108864) {
        updating_value = true;
        editablecell_changes.value = /*_headers*/
        ctx[26][
          /*i*/
          ctx[144]
        ].value;
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_el && dirty[0] & /*els, _headers*/
      100663296) {
        updating_el = true;
        editablecell_changes.el = /*els*/
        ctx[25][
          /*id*/
          ctx[140]
        ].input;
        add_flush_callback(() => updating_el = false);
      }
      editablecell.$set(editablecell_changes);
      const sorticon_changes = {};
      if (dirty[0] & /*sort_by, _headers, sort_direction*/
      872415232)
        sorticon_changes.direction = /*sort_by*/
        ctx[29] === /*i*/
        ctx[144] ? (
          /*sort_direction*/
          ctx[28]
        ) : null;
      if (dirty[0] & /*i18n*/
      1024)
        sorticon_changes.i18n = /*i18n*/
        ctx[10];
      sorticon.$set(sorticon_changes);
      if (
        /*editable*/
        ctx[7]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_4(ctx);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*_headers, sort_by, sort_direction*/
      872415232 && th_aria_sort_value !== (th_aria_sort_value = /*get_sort_status*/
      ctx[50](
        /*value*/
        ctx[139],
        /*sort_by*/
        ctx[29],
        /*sort_direction*/
        ctx[28]
      ))) {
        attr(th, "aria-sort", th_aria_sort_value);
      }
      if (!current || dirty[0] & /*_headers*/
      67108864) {
        set_style(
          th,
          "width",
          /*get_cell_width*/
          ctx[56](
            /*i*/
            ctx[144]
          )
        );
      }
      if (!current || dirty[0] & /*_headers, show_row_numbers*/
      67125248 | dirty[1] & /*actual_pinned_columns*/
      4) {
        set_style(
          th,
          "left",
          /*i*/
          ctx[144] < /*actual_pinned_columns*/
          ctx[33] ? (
            /*i*/
            ctx[144] === 0 ? (
              /*show_row_numbers*/
              ctx[14] ? "var(--cell-width-row-number)" : "0"
            ) : `calc(${/*show_row_numbers*/
            ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
              /*i*/
              ctx[144]
            ).fill(0).map(func_2).join(" + ")})`
          ) : "auto"
        );
      }
      if (!current || dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*actual_pinned_columns*/
      4) {
        toggle_class(
          th,
          "frozen-column",
          /*i*/
          ctx[144] < /*actual_pinned_columns*/
          ctx[33]
        );
      }
      if (!current || dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*actual_pinned_columns*/
      4) {
        toggle_class(
          th,
          "last-frozen",
          /*i*/
          ctx[144] === /*actual_pinned_columns*/
          ctx[33] - 1
        );
      }
      if (!current || dirty[0] & /*_headers*/
      67108864 | dirty[1] & /*header_edit, selected_header*/
      192) {
        toggle_class(
          th,
          "focus",
          /*header_edit*/
          ctx[37] === /*i*/
          ctx[144] || /*selected_header*/
          ctx[38] === /*i*/
          ctx[144]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablecell.$$.fragment, local);
      transition_in(sorticon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editablecell.$$.fragment, local);
      transition_out(sorticon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      destroy_component(editablecell);
      destroy_component(sorticon);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_thead_slot(ctx) {
  let tr;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let if_block = (
    /*show_row_numbers*/
    ctx[14] && create_if_block_5()
  );
  let each_value_1 = ensure_array_like(
    /*_headers*/
    ctx[26]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[140]
  );
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  return {
    c() {
      tr = element("tr");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      tr = claim_element(nodes, "TR", { slot: true, class: true });
      var tr_nodes = children(tr);
      if (if_block)
        if_block.l(tr_nodes);
      t = claim_space(tr_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(tr, "slot", "thead");
      attr(tr, "class", "svelte-m6pdii");
    },
    m(target, anchor) {
      insert_hydration(target, tr, anchor);
      if (if_block)
        if_block.m(tr, null);
      append_hydration(tr, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*show_row_numbers*/
        ctx2[14]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_5();
          if_block.c();
          if_block.m(tr, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*_headers, sort_by, sort_direction, show_row_numbers, editable, i18n, max_chars, latex_delimiters, line_breaks, root, els*/
      906516160 | dirty[1] & /*get_sort_status, get_cell_width, actual_pinned_columns, header_edit, selected_header, toggle_header_button, handle_sort, end_header_edit, edit_header*/
      1122500804 | dirty[2] & /*toggle_header_menu*/
      4) {
        each_value_1 = ensure_array_like(
          /*_headers*/
          ctx2[26]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, tr, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_3(ctx) {
  let td;
  let t_value = (
    /*index*/
    ctx[137] + 1 + ""
  );
  let t;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true, tabindex: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(td, "class", "row-number frozen-column always-frozen svelte-m6pdii");
      set_style(td, "left", "0");
      attr(td, "tabindex", "-1");
    },
    m(target, anchor) {
      insert_hydration(target, td, anchor);
      append_hydration(td, t);
    },
    p(ctx2, dirty) {
      if (dirty[4] & /*index*/
      8192 && t_value !== (t_value = /*index*/
      ctx2[137] + 1 + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let button;
  let textContent = "⋮";
  let mounted;
  let dispose;
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[88](
        /*index*/
        ctx[137],
        /*j*/
        ctx[142],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-15lbpst")
        button.textContent = textContent;
      this.h();
    },
    h() {
      attr(button, "class", "cell-menu-button svelte-m6pdii");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(key_1, ctx) {
  var _a, _b;
  let td;
  let div;
  let editablecell;
  let updating_value;
  let updating_el;
  let t0;
  let show_if = (
    /*editable*/
    ctx[7] && should_show_cell_menu(
      [
        /*index*/
        ctx[137],
        /*j*/
        ctx[142]
      ],
      /*selected_cells*/
      ctx[23],
      /*editable*/
      ctx[7]
    )
  );
  let t1;
  let td_tabindex_value;
  let td_style_value;
  let td_class_value;
  let id = (
    /*id*/
    ctx[140]
  );
  let current;
  let mounted;
  let dispose;
  function editablecell_value_binding(value) {
    ctx[84](
      value,
      /*index*/
      ctx[137],
      /*j*/
      ctx[142]
    );
  }
  function editablecell_el_binding(value) {
    ctx[85](
      value,
      /*id*/
      ctx[140]
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[87](
        /*index*/
        ctx[137],
        /*j*/
        ctx[142]
      )
    );
  }
  let editablecell_props = {
    display_value: (
      /*display_value*/
      (_b = (_a = ctx[21]) == null ? void 0 : _a[
        /*index*/
        ctx[137]
      ]) == null ? void 0 : _b[
        /*j*/
        ctx[142]
      ]
    ),
    latex_delimiters: (
      /*latex_delimiters*/
      ctx[6]
    ),
    line_breaks: (
      /*line_breaks*/
      ctx[12]
    ),
    editable: (
      /*editable*/
      ctx[7]
    ),
    edit: dequal(
      /*editing*/
      ctx[35],
      [
        /*index*/
        ctx[137],
        /*j*/
        ctx[142]
      ]
    ),
    datatype: Array.isArray(
      /*datatype*/
      ctx[1]
    ) ? (
      /*datatype*/
      ctx[1][
        /*j*/
        ctx[142]
      ]
    ) : (
      /*datatype*/
      ctx[1]
    ),
    clear_on_focus: (
      /*clear_on_focus*/
      ctx[36]
    ),
    root: (
      /*root*/
      ctx[9]
    ),
    max_chars: (
      /*max_chars*/
      ctx[19]
    )
  };
  if (
    /*data*/
    ctx[27][
      /*index*/
      ctx[137]
    ][
      /*j*/
      ctx[142]
    ].value !== void 0
  ) {
    editablecell_props.value = /*data*/
    ctx[27][
      /*index*/
      ctx[137]
    ][
      /*j*/
      ctx[142]
    ].value;
  }
  if (
    /*els*/
    ctx[25][
      /*id*/
      ctx[140]
    ].input !== void 0
  ) {
    editablecell_props.el = /*els*/
    ctx[25][
      /*id*/
      ctx[140]
    ].input;
  }
  editablecell = new EditableCell({ props: editablecell_props });
  binding_callbacks.push(() => bind(editablecell, "value", editablecell_value_binding));
  binding_callbacks.push(() => bind(editablecell, "el", editablecell_el_binding));
  editablecell.$on(
    "blur",
    /*blur_handler*/
    ctx[86]
  );
  editablecell.$on("focus", focus_handler);
  let if_block = show_if && create_if_block_2(ctx);
  const assign_td = () => (
    /*td_binding_1*/
    ctx[89](td, id)
  );
  const unassign_td = () => (
    /*td_binding_1*/
    ctx[89](null, id)
  );
  function touchstart_handler(...args) {
    return (
      /*touchstart_handler*/
      ctx[90](
        /*index*/
        ctx[137],
        /*j*/
        ctx[142],
        ...args
      )
    );
  }
  function click_handler_3(...args) {
    return (
      /*click_handler_3*/
      ctx[91](
        /*index*/
        ctx[137],
        /*j*/
        ctx[142],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      td = element("td");
      div = element("div");
      create_component(editablecell.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l(nodes) {
      td = claim_element(nodes, "TD", { tabindex: true, style: true, class: true });
      var td_nodes = children(td);
      div = claim_element(td_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(editablecell.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      t1 = claim_space(td_nodes);
      td_nodes.forEach(detach);
      this.h();
    },
    h() {
      var _a2, _b2;
      attr(div, "class", "cell-wrap svelte-m6pdii");
      attr(td, "tabindex", td_tabindex_value = /*show_row_numbers*/
      ctx[14] && /*j*/
      ctx[142] === 0 ? -1 : 0);
      attr(td, "style", td_style_value = "width: " + /*get_cell_width*/
      ctx[56](
        /*j*/
        ctx[142]
      ) + "; left: " + /*j*/
      (ctx[142] < /*actual_pinned_columns*/
      ctx[33] ? (
        /*j*/
        ctx[142] === 0 ? (
          /*show_row_numbers*/
          ctx[14] ? "var(--cell-width-row-number)" : "0"
        ) : `calc(${/*show_row_numbers*/
        ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
          /*j*/
          ctx[142]
        ).fill(0).map(func_1).join(" + ")})`
      ) : "auto") + "; " + /*styling*/
      (((_b2 = (_a2 = ctx[22]) == null ? void 0 : _a2[
        /*index*/
        ctx[137]
      ]) == null ? void 0 : _b2[
        /*j*/
        ctx[142]
      ]) || ""));
      attr(td, "class", td_class_value = null_to_empty(is_cell_selected(
        [
          /*index*/
          ctx[137],
          /*j*/
          ctx[142]
        ],
        /*selected_cells*/
        ctx[23]
      )) + " svelte-m6pdii");
      toggle_class(
        td,
        "frozen-column",
        /*j*/
        ctx[142] < /*actual_pinned_columns*/
        ctx[33]
      );
      toggle_class(
        td,
        "last-frozen",
        /*j*/
        ctx[142] === /*actual_pinned_columns*/
        ctx[33] - 1
      );
      toggle_class(
        td,
        "flash",
        /*copy_flash*/
        ctx[43] && is_cell_selected(
          [
            /*index*/
            ctx[137],
            /*j*/
            ctx[142]
          ],
          /*selected_cells*/
          ctx[23]
        )
      );
      toggle_class(
        td,
        "menu-active",
        /*active_cell_menu*/
        ctx[39] && /*active_cell_menu*/
        ctx[39].row === /*index*/
        ctx[137] && /*active_cell_menu*/
        ctx[39].col === /*j*/
        ctx[142]
      );
      this.first = td;
    },
    m(target, anchor) {
      insert_hydration(target, td, anchor);
      append_hydration(td, div);
      mount_component(editablecell, div, null);
      append_hydration(div, t0);
      if (if_block)
        if_block.m(div, null);
      append_hydration(td, t1);
      assign_td();
      current = true;
      if (!mounted) {
        dispose = [
          listen(td, "touchstart", touchstart_handler),
          listen(td, "mousedown", mousedown_handler),
          listen(td, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b2, _c, _d;
      ctx = new_ctx;
      const editablecell_changes = {};
      if (dirty[0] & /*display_value*/
      2097152 | dirty[4] & /*index, item*/
      24576)
        editablecell_changes.display_value = /*display_value*/
        (_b2 = (_a2 = ctx[21]) == null ? void 0 : _a2[
          /*index*/
          ctx[137]
        ]) == null ? void 0 : _b2[
          /*j*/
          ctx[142]
        ];
      if (dirty[0] & /*latex_delimiters*/
      64)
        editablecell_changes.latex_delimiters = /*latex_delimiters*/
        ctx[6];
      if (dirty[0] & /*line_breaks*/
      4096)
        editablecell_changes.line_breaks = /*line_breaks*/
        ctx[12];
      if (dirty[0] & /*editable*/
      128)
        editablecell_changes.editable = /*editable*/
        ctx[7];
      if (dirty[1] & /*editing*/
      16 | dirty[4] & /*index, item*/
      24576)
        editablecell_changes.edit = dequal(
          /*editing*/
          ctx[35],
          [
            /*index*/
            ctx[137],
            /*j*/
            ctx[142]
          ]
        );
      if (dirty[0] & /*datatype*/
      2 | dirty[4] & /*item*/
      16384)
        editablecell_changes.datatype = Array.isArray(
          /*datatype*/
          ctx[1]
        ) ? (
          /*datatype*/
          ctx[1][
            /*j*/
            ctx[142]
          ]
        ) : (
          /*datatype*/
          ctx[1]
        );
      if (dirty[1] & /*clear_on_focus*/
      32)
        editablecell_changes.clear_on_focus = /*clear_on_focus*/
        ctx[36];
      if (dirty[0] & /*root*/
      512)
        editablecell_changes.root = /*root*/
        ctx[9];
      if (dirty[0] & /*max_chars*/
      524288)
        editablecell_changes.max_chars = /*max_chars*/
        ctx[19];
      if (!updating_value && dirty[0] & /*data*/
      134217728 | dirty[4] & /*index, item*/
      24576) {
        updating_value = true;
        editablecell_changes.value = /*data*/
        ctx[27][
          /*index*/
          ctx[137]
        ][
          /*j*/
          ctx[142]
        ].value;
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_el && dirty[0] & /*els*/
      33554432 | dirty[4] & /*item*/
      16384) {
        updating_el = true;
        editablecell_changes.el = /*els*/
        ctx[25][
          /*id*/
          ctx[140]
        ].input;
        add_flush_callback(() => updating_el = false);
      }
      editablecell.$set(editablecell_changes);
      if (dirty[0] & /*editable, selected_cells*/
      8388736 | dirty[4] & /*index, item*/
      24576)
        show_if = /*editable*/
        ctx[7] && should_show_cell_menu(
          [
            /*index*/
            ctx[137],
            /*j*/
            ctx[142]
          ],
          /*selected_cells*/
          ctx[23],
          /*editable*/
          ctx[7]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*show_row_numbers*/
      16384 | dirty[4] & /*item*/
      16384 && td_tabindex_value !== (td_tabindex_value = /*show_row_numbers*/
      ctx[14] && /*j*/
      ctx[142] === 0 ? -1 : 0)) {
        attr(td, "tabindex", td_tabindex_value);
      }
      if (!current || dirty[0] & /*show_row_numbers, styling*/
      4210688 | dirty[1] & /*actual_pinned_columns*/
      4 | dirty[4] & /*item, index*/
      24576 && td_style_value !== (td_style_value = "width: " + /*get_cell_width*/
      ctx[56](
        /*j*/
        ctx[142]
      ) + "; left: " + /*j*/
      (ctx[142] < /*actual_pinned_columns*/
      ctx[33] ? (
        /*j*/
        ctx[142] === 0 ? (
          /*show_row_numbers*/
          ctx[14] ? "var(--cell-width-row-number)" : "0"
        ) : `calc(${/*show_row_numbers*/
        ctx[14] ? "var(--cell-width-row-number) + " : ""}${Array(
          /*j*/
          ctx[142]
        ).fill(0).map(func_1).join(" + ")})`
      ) : "auto") + "; " + /*styling*/
      (((_d = (_c = ctx[22]) == null ? void 0 : _c[
        /*index*/
        ctx[137]
      ]) == null ? void 0 : _d[
        /*j*/
        ctx[142]
      ]) || ""))) {
        attr(td, "style", td_style_value);
      }
      if (!current || dirty[0] & /*selected_cells*/
      8388608 | dirty[4] & /*index, item*/
      24576 && td_class_value !== (td_class_value = null_to_empty(is_cell_selected(
        [
          /*index*/
          ctx[137],
          /*j*/
          ctx[142]
        ],
        /*selected_cells*/
        ctx[23]
      )) + " svelte-m6pdii")) {
        attr(td, "class", td_class_value);
      }
      if (id !== /*id*/
      ctx[140]) {
        unassign_td();
        id = /*id*/
        ctx[140];
        assign_td();
      }
      if (!current || dirty[0] & /*selected_cells*/
      8388608 | dirty[1] & /*actual_pinned_columns*/
      4 | dirty[4] & /*index, item, item*/
      24576) {
        toggle_class(
          td,
          "frozen-column",
          /*j*/
          ctx[142] < /*actual_pinned_columns*/
          ctx[33]
        );
      }
      if (!current || dirty[0] & /*selected_cells*/
      8388608 | dirty[1] & /*actual_pinned_columns*/
      4 | dirty[4] & /*index, item, item*/
      24576) {
        toggle_class(
          td,
          "last-frozen",
          /*j*/
          ctx[142] === /*actual_pinned_columns*/
          ctx[33] - 1
        );
      }
      if (!current || dirty[0] & /*selected_cells, selected_cells*/
      8388608 | dirty[1] & /*copy_flash*/
      4096 | dirty[4] & /*index, item, index, item*/
      24576) {
        toggle_class(
          td,
          "flash",
          /*copy_flash*/
          ctx[43] && is_cell_selected(
            [
              /*index*/
              ctx[137],
              /*j*/
              ctx[142]
            ],
            /*selected_cells*/
            ctx[23]
          )
        );
      }
      if (!current || dirty[0] & /*selected_cells*/
      8388608 | dirty[1] & /*active_cell_menu*/
      256 | dirty[4] & /*index, item, index, item*/
      24576) {
        toggle_class(
          td,
          "menu-active",
          /*active_cell_menu*/
          ctx[39] && /*active_cell_menu*/
          ctx[39].row === /*index*/
          ctx[137] && /*active_cell_menu*/
          ctx[39].col === /*j*/
          ctx[142]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      destroy_component(editablecell);
      if (if_block)
        if_block.d();
      unassign_td();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_tbody_slot(ctx) {
  let tr;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let if_block = (
    /*show_row_numbers*/
    ctx[14] && create_if_block_3(ctx)
  );
  let each_value = ensure_array_like(
    /*item*/
    ctx[138]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[140]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      tr = element("tr");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      tr = claim_element(nodes, "TR", { slot: true, class: true });
      var tr_nodes = children(tr);
      if (if_block)
        if_block.l(tr_nodes);
      t = claim_space(tr_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(tr, "slot", "tbody");
      attr(tr, "class", "svelte-m6pdii");
      toggle_class(
        tr,
        "row_odd",
        /*index*/
        ctx[137] % 2 === 0
      );
    },
    m(target, anchor) {
      insert_hydration(target, tr, anchor);
      if (if_block)
        if_block.m(tr, null);
      append_hydration(tr, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*show_row_numbers*/
        ctx2[14]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(tr, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*show_row_numbers, styling, selected_cells, els, editable, display_value, latex_delimiters, line_breaks, datatype, root, max_chars, data*/
      182997698 | dirty[1] & /*get_cell_width, actual_pinned_columns, copy_flash, active_cell_menu, handle_cell_click, toggle_cell_menu, editing, clear_on_focus, parent*/
      234885429 | dirty[4] & /*item, index*/
      24576) {
        each_value = ensure_array_like(
          /*item*/
          ctx2[138]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tr, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[4] & /*index*/
      8192) {
        toggle_class(
          tr,
          "row_odd",
          /*index*/
          ctx2[137] % 2 === 0
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_default_slot$1(ctx) {
  let virtualtable;
  let updating_items;
  let updating_actual_height;
  let updating_table_scrollbar_width;
  let current;
  function virtualtable_items_binding(value) {
    ctx[98](value);
  }
  function virtualtable_actual_height_binding(value) {
    ctx[99](value);
  }
  function virtualtable_table_scrollbar_width_binding(value) {
    ctx[100](value);
  }
  let virtualtable_props = {
    max_height: (
      /*max_height*/
      ctx[11]
    ),
    selected: (
      /*selected_index*/
      ctx[48]
    ),
    disable_scroll: (
      /*active_cell_menu*/
      ctx[39] !== null || /*active_header_menu*/
      ctx[40] !== null
    ),
    $$slots: {
      tbody: [
        create_tbody_slot,
        ({ index, item }) => ({ 137: index, 138: item }),
        ({ index, item }) => [0, 0, 0, 0, (index ? 8192 : 0) | (item ? 16384 : 0)]
      ],
      thead: [create_thead_slot],
      default: [create_default_slot_1]
    },
    $$scope: { ctx }
  };
  if (
    /*data*/
    ctx[27] !== void 0
  ) {
    virtualtable_props.items = /*data*/
    ctx[27];
  }
  if (
    /*table_height*/
    ctx[44] !== void 0
  ) {
    virtualtable_props.actual_height = /*table_height*/
    ctx[44];
  }
  if (
    /*scrollbar_width*/
    ctx[45] !== void 0
  ) {
    virtualtable_props.table_scrollbar_width = /*scrollbar_width*/
    ctx[45];
  }
  virtualtable = new VirtualTable({ props: virtualtable_props });
  binding_callbacks.push(() => bind(virtualtable, "items", virtualtable_items_binding));
  binding_callbacks.push(() => bind(virtualtable, "actual_height", virtualtable_actual_height_binding));
  binding_callbacks.push(() => bind(virtualtable, "table_scrollbar_width", virtualtable_table_scrollbar_width_binding));
  return {
    c() {
      create_component(virtualtable.$$.fragment);
    },
    l(nodes) {
      claim_component(virtualtable.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(virtualtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const virtualtable_changes = {};
      if (dirty[0] & /*max_height*/
      2048)
        virtualtable_changes.max_height = /*max_height*/
        ctx2[11];
      if (dirty[1] & /*selected_index*/
      131072)
        virtualtable_changes.selected = /*selected_index*/
        ctx2[48];
      if (dirty[1] & /*active_cell_menu, active_header_menu*/
      768)
        virtualtable_changes.disable_scroll = /*active_cell_menu*/
        ctx2[39] !== null || /*active_header_menu*/
        ctx2[40] !== null;
      if (dirty[0] & /*show_row_numbers, styling, selected_cells, els, editable, display_value, latex_delimiters, line_breaks, datatype, root, max_chars, data, _headers, sort_by, sort_direction, i18n, label*/
      1055413958 | dirty[1] & /*actual_pinned_columns, copy_flash, active_cell_menu, editing, clear_on_focus, parent, header_edit, selected_header*/
      4597 | dirty[4] & /*$$scope, index, item*/
      8413184) {
        virtualtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty[0] & /*data*/
      134217728) {
        updating_items = true;
        virtualtable_changes.items = /*data*/
        ctx2[27];
        add_flush_callback(() => updating_items = false);
      }
      if (!updating_actual_height && dirty[1] & /*table_height*/
      8192) {
        updating_actual_height = true;
        virtualtable_changes.actual_height = /*table_height*/
        ctx2[44];
        add_flush_callback(() => updating_actual_height = false);
      }
      if (!updating_table_scrollbar_width && dirty[1] & /*scrollbar_width*/
      16384) {
        updating_table_scrollbar_width = true;
        virtualtable_changes.table_scrollbar_width = /*scrollbar_width*/
        ctx2[45];
        add_flush_callback(() => updating_table_scrollbar_width = false);
      }
      virtualtable.$set(virtualtable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(virtualtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(virtualtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(virtualtable, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let cellmenu;
  let current;
  cellmenu = new CellMenu({
    props: {
      x: (
        /*active_cell_menu*/
        ctx[39].x
      ),
      y: (
        /*active_cell_menu*/
        ctx[39].y
      ),
      row: (
        /*active_cell_menu*/
        ctx[39].row
      ),
      col_count: (
        /*col_count*/
        ctx[4]
      ),
      row_count: (
        /*row_count*/
        ctx[5]
      ),
      on_add_row_above: (
        /*func_3*/
        ctx[105]
      ),
      on_add_row_below: (
        /*func_4*/
        ctx[106]
      ),
      on_add_column_left: (
        /*func_5*/
        ctx[107]
      ),
      on_add_column_right: (
        /*func_6*/
        ctx[108]
      ),
      on_delete_row: (
        /*func_7*/
        ctx[109]
      ),
      on_delete_col: (
        /*func_8*/
        ctx[110]
      ),
      can_delete_rows: (
        /*data*/
        ctx[27].length > 1
      ),
      can_delete_cols: (
        /*data*/
        ctx[27][0].length > 1
      ),
      i18n: (
        /*i18n*/
        ctx[10]
      )
    }
  });
  return {
    c() {
      create_component(cellmenu.$$.fragment);
    },
    l(nodes) {
      claim_component(cellmenu.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(cellmenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cellmenu_changes = {};
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.x = /*active_cell_menu*/
        ctx2[39].x;
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.y = /*active_cell_menu*/
        ctx2[39].y;
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.row = /*active_cell_menu*/
        ctx2[39].row;
      if (dirty[0] & /*col_count*/
      16)
        cellmenu_changes.col_count = /*col_count*/
        ctx2[4];
      if (dirty[0] & /*row_count*/
      32)
        cellmenu_changes.row_count = /*row_count*/
        ctx2[5];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_row_above = /*func_3*/
        ctx2[105];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_row_below = /*func_4*/
        ctx2[106];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_column_left = /*func_5*/
        ctx2[107];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_column_right = /*func_6*/
        ctx2[108];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_delete_row = /*func_7*/
        ctx2[109];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_delete_col = /*func_8*/
        ctx2[110];
      if (dirty[0] & /*data*/
      134217728)
        cellmenu_changes.can_delete_rows = /*data*/
        ctx2[27].length > 1;
      if (dirty[0] & /*data*/
      134217728)
        cellmenu_changes.can_delete_cols = /*data*/
        ctx2[27][0].length > 1;
      if (dirty[0] & /*i18n*/
      1024)
        cellmenu_changes.i18n = /*i18n*/
        ctx2[10];
      cellmenu.$set(cellmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cellmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cellmenu, detaching);
    }
  };
}
function create_if_block(ctx) {
  let cellmenu;
  let current;
  cellmenu = new CellMenu({
    props: {
      i18n: (
        /*i18n*/
        ctx[10]
      ),
      x: (
        /*active_header_menu*/
        ctx[40].x
      ),
      y: (
        /*active_header_menu*/
        ctx[40].y
      ),
      row: -1,
      col_count: (
        /*col_count*/
        ctx[4]
      ),
      row_count: (
        /*row_count*/
        ctx[5]
      ),
      on_add_row_above: (
        /*func_9*/
        ctx[111]
      ),
      on_add_row_below: (
        /*func_10*/
        ctx[112]
      ),
      on_add_column_left: (
        /*func_11*/
        ctx[113]
      ),
      on_add_column_right: (
        /*func_12*/
        ctx[114]
      ),
      on_delete_row: (
        /*func_13*/
        ctx[115]
      ),
      on_delete_col: (
        /*func_14*/
        ctx[116]
      ),
      can_delete_rows: false,
      can_delete_cols: (
        /*data*/
        ctx[27][0].length > 1
      )
    }
  });
  return {
    c() {
      create_component(cellmenu.$$.fragment);
    },
    l(nodes) {
      claim_component(cellmenu.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(cellmenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cellmenu_changes = {};
      if (dirty[0] & /*i18n*/
      1024)
        cellmenu_changes.i18n = /*i18n*/
        ctx2[10];
      if (dirty[1] & /*active_header_menu*/
      512)
        cellmenu_changes.x = /*active_header_menu*/
        ctx2[40].x;
      if (dirty[1] & /*active_header_menu*/
      512)
        cellmenu_changes.y = /*active_header_menu*/
        ctx2[40].y;
      if (dirty[0] & /*col_count*/
      16)
        cellmenu_changes.col_count = /*col_count*/
        ctx2[4];
      if (dirty[0] & /*row_count*/
      32)
        cellmenu_changes.row_count = /*row_count*/
        ctx2[5];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_row_above = /*func_9*/
        ctx2[111];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_add_row_below = /*func_10*/
        ctx2[112];
      if (dirty[1] & /*active_header_menu*/
      512)
        cellmenu_changes.on_add_column_left = /*func_11*/
        ctx2[113];
      if (dirty[1] & /*active_header_menu*/
      512)
        cellmenu_changes.on_add_column_right = /*func_12*/
        ctx2[114];
      if (dirty[1] & /*active_cell_menu*/
      256)
        cellmenu_changes.on_delete_row = /*func_13*/
        ctx2[115];
      if (dirty[1] & /*active_header_menu*/
      512)
        cellmenu_changes.on_delete_col = /*func_14*/
        ctx2[116];
      if (dirty[0] & /*data*/
      134217728)
        cellmenu_changes.can_delete_cols = /*data*/
        ctx2[27][0].length > 1;
      cellmenu.$set(cellmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cellmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cellmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cellmenu, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let div2;
  let div0;
  let t0;
  let toolbar;
  let t1;
  let div1;
  let t2;
  let table_1;
  let t3;
  let thead;
  let tr0;
  let t4;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t5;
  let tbody;
  let tr1;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let table_1_resize_listener;
  let t6;
  let upload_1;
  let updating_dragging;
  let t7;
  let t8;
  let if_block5_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*label*/
    ctx[2] && /*label*/
    ctx[2].length !== 0 && /*show_label*/
    ctx[3] && create_if_block_10(ctx)
  );
  toolbar = new Toolbar({
    props: {
      show_fullscreen_button: (
        /*show_fullscreen_button*/
        ctx[17]
      ),
      is_fullscreen: (
        /*is_fullscreen*/
        ctx[41]
      ),
      on_copy: (
        /*handle_copy*/
        ctx[63]
      ),
      show_copy_button: (
        /*show_copy_button*/
        ctx[18]
      ),
      show_search: (
        /*show_search*/
        ctx[20]
      ),
      on_commit_filter: (
        /*commit_filter*/
        ctx[70]
      ),
      current_search_query: (
        /*current_search_query*/
        ctx[47]
      )
    }
  });
  toolbar.$on(
    "click",
    /*toggle_fullscreen*/
    ctx[62]
  );
  toolbar.$on(
    "search",
    /*search_handler*/
    ctx[77]
  );
  let if_block1 = (
    /*selected*/
    ctx[24] !== false && /*selected_cells*/
    ctx[23].length === 1 && create_if_block_9(ctx)
  );
  let if_block2 = (
    /*label*/
    ctx[2] && /*label*/
    ctx[2].length !== 0 && create_if_block_8(ctx)
  );
  let if_block3 = (
    /*show_row_numbers*/
    ctx[14] && create_if_block_7()
  );
  let each_value_3 = ensure_array_like(
    /*_headers*/
    ctx[26]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[140]
  );
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
  }
  let each_value_2 = ensure_array_like(
    /*max*/
    ctx[49]
  );
  const get_key_1 = (ctx2) => (
    /*id*/
    ctx2[140]
  );
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  function upload_1_dragging_binding(value) {
    ctx[101](value);
  }
  let upload_1_props = {
    upload: (
      /*upload*/
      ctx[15]
    ),
    stream_handler: (
      /*stream_handler*/
      ctx[16]
    ),
    flex: false,
    center: false,
    boundedheight: false,
    disable_click: true,
    root: (
      /*root*/
      ctx[9]
    ),
    aria_label: (
      /*i18n*/
      ctx[10]("dataframe.drop_to_upload")
    ),
    $$slots: { default: [create_default_slot$1] },
    $$scope: { ctx }
  };
  if (
    /*dragging*/
    ctx[42] !== void 0
  ) {
    upload_1_props.dragging = /*dragging*/
    ctx[42];
  }
  upload_1 = new Upload({ props: upload_1_props });
  binding_callbacks.push(() => bind(upload_1, "dragging", upload_1_dragging_binding));
  upload_1.$on(
    "load",
    /*load_handler*/
    ctx[102]
  );
  let if_block4 = (
    /*active_cell_menu*/
    ctx[39] && create_if_block_1(ctx)
  );
  let if_block5 = (
    /*active_header_menu*/
    ctx[40] !== null && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(toolbar.$$.fragment);
      t1 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      table_1 = element("table");
      if (if_block2)
        if_block2.c();
      t3 = space();
      thead = element("thead");
      tr0 = element("tr");
      if (if_block3)
        if_block3.c();
      t4 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t5 = space();
      tbody = element("tbody");
      tr1 = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t6 = space();
      create_component(upload_1.$$.fragment);
      t7 = space();
      if (if_block4)
        if_block4.c();
      t8 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      claim_component(toolbar.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true,
        style: true,
        role: true,
        tabindex: true
      });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      table_1 = claim_element(div1_nodes, "TABLE", { class: true });
      var table_1_nodes = children(table_1);
      if (if_block2)
        if_block2.l(table_1_nodes);
      t3 = claim_space(table_1_nodes);
      thead = claim_element(table_1_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr0 = claim_element(thead_nodes, "TR", { class: true });
      var tr0_nodes = children(tr0);
      if (if_block3)
        if_block3.l(tr0_nodes);
      t4 = claim_space(tr0_nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr0_nodes);
      }
      tr0_nodes.forEach(detach);
      thead_nodes.forEach(detach);
      t5 = claim_space(table_1_nodes);
      tbody = claim_element(table_1_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      tr1 = claim_element(tbody_nodes, "TR", { class: true });
      var tr1_nodes = children(tr1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr1_nodes);
      }
      tr1_nodes.forEach(detach);
      tbody_nodes.forEach(detach);
      table_1_nodes.forEach(detach);
      t6 = claim_space(div1_nodes);
      claim_component(upload_1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      t7 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t8 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      if_block5_anchor = empty();
      this.h();
    },
    h() {
      attr(div0, "class", "header-row svelte-m6pdii");
      attr(tr0, "class", "svelte-m6pdii");
      attr(thead, "class", "svelte-m6pdii");
      attr(tr1, "class", "svelte-m6pdii");
      attr(table_1, "class", "svelte-m6pdii");
      toggle_class(
        table_1,
        "fixed-layout",
        /*column_widths*/
        ctx[13].length != 0
      );
      attr(div1, "class", "table-wrap svelte-m6pdii");
      set_style(
        div1,
        "height",
        /*table_height*/
        ctx[44] + "px"
      );
      attr(div1, "role", "grid");
      attr(div1, "tabindex", "0");
      toggle_class(
        div1,
        "dragging",
        /*dragging*/
        ctx[42]
      );
      toggle_class(div1, "no-wrap", !/*wrap*/
      ctx[8]);
      toggle_class(
        div1,
        "menu-open",
        /*active_cell_menu*/
        ctx[39] || /*active_header_menu*/
        ctx[40]
      );
      attr(div2, "class", "table-container svelte-m6pdii");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t0);
      mount_component(toolbar, div0, null);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration(div1, t2);
      append_hydration(div1, table_1);
      if (if_block2)
        if_block2.m(table_1, null);
      append_hydration(table_1, t3);
      append_hydration(table_1, thead);
      append_hydration(thead, tr0);
      if (if_block3)
        if_block3.m(tr0, null);
      append_hydration(tr0, t4);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr0, null);
        }
      }
      append_hydration(table_1, t5);
      append_hydration(table_1, tbody);
      append_hydration(tbody, tr1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr1, null);
        }
      }
      table_1_resize_listener = resize_observer_content_box.observe(
        table_1,
        /*table_1_elementresizecontentbox_handler*/
        ctx[82].bind(table_1)
      );
      ctx[83](table_1);
      append_hydration(div1, t6);
      mount_component(upload_1, div1, null);
      ctx[103](div1);
      insert_hydration(target, t7, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration(target, t8, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration(target, if_block5_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window_1,
            "resize",
            /*resize_handler*/
            ctx[76]
          ),
          listen(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[104]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*label*/
        ctx2[2] && /*label*/
        ctx2[2].length !== 0 && /*show_label*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const toolbar_changes = {};
      if (dirty[0] & /*show_fullscreen_button*/
      131072)
        toolbar_changes.show_fullscreen_button = /*show_fullscreen_button*/
        ctx2[17];
      if (dirty[1] & /*is_fullscreen*/
      1024)
        toolbar_changes.is_fullscreen = /*is_fullscreen*/
        ctx2[41];
      if (dirty[0] & /*show_copy_button*/
      262144)
        toolbar_changes.show_copy_button = /*show_copy_button*/
        ctx2[18];
      if (dirty[0] & /*show_search*/
      1048576)
        toolbar_changes.show_search = /*show_search*/
        ctx2[20];
      if (dirty[1] & /*current_search_query*/
      65536)
        toolbar_changes.current_search_query = /*current_search_query*/
        ctx2[47];
      toolbar.$set(toolbar_changes);
      if (
        /*selected*/
        ctx2[24] !== false && /*selected_cells*/
        ctx2[23].length === 1
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*label*/
        ctx2[2] && /*label*/
        ctx2[2].length !== 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_8(ctx2);
          if_block2.c();
          if_block2.m(table_1, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*show_row_numbers*/
        ctx2[14]
      ) {
        if (if_block3)
          ;
        else {
          if_block3 = create_if_block_7();
          if_block3.c();
          if_block3.m(tr0, t4);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty[0] & /*_headers, sort_by, sort_direction, column_widths, show_row_numbers, i18n, latex_delimiters, line_breaks, root, editable*/
      872445632 | dirty[1] & /*get_sort_status, actual_pinned_columns, header_edit, handle_sort*/
      2621508) {
        each_value_3 = ensure_array_like(
          /*_headers*/
          ctx2[26]
        );
        group_outros();
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_3, each0_lookup, tr0, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
        check_outros();
      }
      if (dirty[0] & /*cells, latex_delimiters, line_breaks, datatype, root, editable*/
      1073746626 | dirty[1] & /*max*/
      262144) {
        each_value_2 = ensure_array_like(
          /*max*/
          ctx2[49]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_2, each1_lookup, tr1, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
        check_outros();
      }
      if (!current || dirty[0] & /*column_widths*/
      8192) {
        toggle_class(
          table_1,
          "fixed-layout",
          /*column_widths*/
          ctx2[13].length != 0
        );
      }
      const upload_1_changes = {};
      if (dirty[0] & /*upload*/
      32768)
        upload_1_changes.upload = /*upload*/
        ctx2[15];
      if (dirty[0] & /*stream_handler*/
      65536)
        upload_1_changes.stream_handler = /*stream_handler*/
        ctx2[16];
      if (dirty[0] & /*root*/
      512)
        upload_1_changes.root = /*root*/
        ctx2[9];
      if (dirty[0] & /*i18n*/
      1024)
        upload_1_changes.aria_label = /*i18n*/
        ctx2[10]("dataframe.drop_to_upload");
      if (dirty[0] & /*max_height, data, show_row_numbers, styling, selected_cells, els, editable, display_value, latex_delimiters, line_breaks, datatype, root, max_chars, _headers, sort_by, sort_direction, i18n, label*/
      1055416006 | dirty[1] & /*selected_index, active_cell_menu, active_header_menu, table_height, scrollbar_width, actual_pinned_columns, copy_flash, editing, clear_on_focus, parent, header_edit, selected_header*/
      160757 | dirty[4] & /*$$scope*/
      8388608) {
        upload_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_dragging && dirty[1] & /*dragging*/
      2048) {
        updating_dragging = true;
        upload_1_changes.dragging = /*dragging*/
        ctx2[42];
        add_flush_callback(() => updating_dragging = false);
      }
      upload_1.$set(upload_1_changes);
      if (!current || dirty[1] & /*table_height*/
      8192) {
        set_style(
          div1,
          "height",
          /*table_height*/
          ctx2[44] + "px"
        );
      }
      if (!current || dirty[1] & /*dragging*/
      2048) {
        toggle_class(
          div1,
          "dragging",
          /*dragging*/
          ctx2[42]
        );
      }
      if (!current || dirty[0] & /*wrap*/
      256) {
        toggle_class(div1, "no-wrap", !/*wrap*/
        ctx2[8]);
      }
      if (!current || dirty[1] & /*active_cell_menu, active_header_menu*/
      768) {
        toggle_class(
          div1,
          "menu-open",
          /*active_cell_menu*/
          ctx2[39] || /*active_header_menu*/
          ctx2[40]
        );
      }
      if (
        /*active_cell_menu*/
        ctx2[39]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*active_cell_menu*/
          256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t8.parentNode, t8);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*active_header_menu*/
        ctx2[40] !== null
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[1] & /*active_header_menu*/
          512) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(upload_1.$$.fragment, local);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(upload_1.$$.fragment, local);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t7);
        detach(t8);
        detach(if_block5_anchor);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(toolbar);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      table_1_resize_listener();
      ctx[83](null);
      destroy_component(upload_1);
      ctx[103](null);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function make_id() {
  return Math.random().toString(36).substring(2, 15);
}
function make_headers(_head, col_count2, els2) {
  let _h = _head || [];
  if (col_count2[1] === "fixed" && _h.length < col_count2[0]) {
    const fill = Array(col_count2[0] - _h.length).fill("").map((_, i) => `${i + _h.length}`);
    _h = _h.concat(fill);
  }
  if (!_h || _h.length === 0) {
    return Array(col_count2[0]).fill(0).map((_, i) => {
      const _id = make_id();
      els2[_id] = { cell: null, input: null };
      return { id: _id, value: JSON.stringify(i + 1) };
    });
  }
  return _h.map((h, i) => {
    const _id = make_id();
    els2[_id] = { cell: null, input: null };
    return { id: _id, value: h ?? "" };
  });
}
const func = (_, idx) => `var(--cell-width-${idx})`;
const func_1 = (_, idx) => `var(--cell-width-${idx})`;
const mousedown_handler = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
const func_2 = (_, idx) => `var(--cell-width-${idx})`;
function instance$1($$self, $$props, $$invalidate) {
  let max;
  let selected_index;
  let { datatype } = $$props;
  let { label = null } = $$props;
  let { show_label = true } = $$props;
  let { headers = [] } = $$props;
  let { values = [] } = $$props;
  let { col_count } = $$props;
  let { row_count } = $$props;
  let { latex_delimiters } = $$props;
  let { editable = true } = $$props;
  let { wrap = false } = $$props;
  let { root } = $$props;
  let { i18n } = $$props;
  let { max_height = 500 } = $$props;
  let { line_breaks = true } = $$props;
  let { column_widths = [] } = $$props;
  let { show_row_numbers = false } = $$props;
  let { upload } = $$props;
  let { stream_handler } = $$props;
  let { show_fullscreen_button = false } = $$props;
  let { show_copy_button = false } = $$props;
  let { value_is_output = false } = $$props;
  let { max_chars = void 0 } = $$props;
  let { show_search = "none" } = $$props;
  let { pinned_columns = 0 } = $$props;
  let actual_pinned_columns = 0;
  let selected_cells = [];
  let selected = false;
  let { display_value = null } = $$props;
  let { styling = null } = $$props;
  let t_rect;
  let els = {};
  const dispatch = createEventDispatcher();
  let editing = false;
  let clear_on_focus = false;
  let header_edit = false;
  let selected_header = false;
  let active_cell_menu = null;
  let active_header_menu = null;
  let is_fullscreen = false;
  let dragging = false;
  let copy_flash = false;
  let color_accent_copied;
  onMount(() => {
    const color = getComputedStyle(document.documentElement).getPropertyValue("--color-accent").trim();
    color_accent_copied = color + "40";
    document.documentElement.style.setProperty("--color-accent-copied", color_accent_copied);
  });
  const get_data_at = (row, col) => {
    var _a, _b;
    return (_b = (_a = data == null ? void 0 : data[row]) == null ? void 0 : _a[col]) == null ? void 0 : _b.value;
  };
  function process_data(_values) {
    const data_row_length = _values.length;
    return Array(row_count[1] === "fixed" ? row_count[0] : data_row_length).fill(0).map((_, i) => {
      return Array(col_count[1] === "fixed" ? col_count[0] : data_row_length > 0 ? _values[0].length : headers.length).fill(0).map((_2, j) => {
        var _a;
        const id = make_id();
        $$invalidate(25, els[id] = els[id] || { input: null, cell: null }, els);
        const obj = { value: ((_a = _values == null ? void 0 : _values[i]) == null ? void 0 : _a[j]) ?? "", id };
        return obj;
      });
    });
  }
  let _headers = make_headers(headers, col_count, els);
  let old_headers = headers;
  let data = [[]];
  let old_val = void 0;
  let previous_headers = _headers.map((h) => h.value);
  let previous_data = data.map((row) => row.map((cell) => String(cell.value)));
  async function trigger_change() {
    if (current_search_query)
      return;
    const current_headers = _headers.map((h) => h.value);
    const current_data = data.map((row) => row.map((cell) => String(cell.value)));
    if (!dequal(current_data, previous_data) || !dequal(current_headers, previous_headers)) {
      dispatch("change", {
        data: data.map((row) => row.map((cell) => cell.value)),
        headers: _headers.map((h) => h.value),
        metadata: null
      });
      if (!value_is_output) {
        dispatch("input");
      }
      previous_data = current_data;
      previous_headers = current_headers;
    }
  }
  function get_sort_status(name, _sort, direction) {
    if (!_sort)
      return "none";
    if (headers[_sort] === name) {
      if (direction === "asc")
        return "ascending";
      if (direction === "des")
        return "descending";
    }
    return "none";
  }
  async function handle_keydown(event) {
    if (selected_header !== false && header_edit === false) {
      switch (event.key) {
        case "ArrowDown":
          $$invalidate(24, selected = [0, selected_header]);
          $$invalidate(38, selected_header = false);
          return;
        case "ArrowLeft":
          $$invalidate(38, selected_header = selected_header > 0 ? selected_header - 1 : selected_header);
          return;
        case "ArrowRight":
          $$invalidate(38, selected_header = selected_header < _headers.length - 1 ? selected_header + 1 : selected_header);
          return;
        case "Escape":
          event.preventDefault();
          $$invalidate(38, selected_header = false);
          break;
        case "Enter":
          event.preventDefault();
          break;
      }
    }
    if (event.key === "Delete" || event.key === "Backspace") {
      if (!editable)
        return;
      if (editing) {
        const [row, col] = editing;
        const input_el = els[data[row][col].id].input;
        if (input_el && input_el.selectionStart !== input_el.selectionEnd) {
          return;
        }
        if (event.key === "Delete" && (input_el == null ? void 0 : input_el.selectionStart) !== (input_el == null ? void 0 : input_el.value.length)) {
          return;
        }
        if (event.key === "Backspace" && (input_el == null ? void 0 : input_el.selectionStart) !== 0) {
          return;
        }
      }
      event.preventDefault();
      if (selected_cells.length > 0) {
        $$invalidate(27, data = handle_delete_key(data, selected_cells));
        dispatch("change", {
          data: data.map((row) => row.map((cell) => cell.value)),
          headers: _headers.map((h) => h.value),
          metadata: null
        });
        if (!value_is_output) {
          dispatch("input");
        }
      }
      return;
    }
    if (event.key === "c" && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      if (selected_cells.length > 0) {
        await handle_copy();
      }
      return;
    }
    if (!selected) {
      return;
    }
    const [i, j] = selected;
    switch (event.key) {
      case "ArrowRight":
      case "ArrowLeft":
      case "ArrowDown":
      case "ArrowUp":
        if (editing)
          break;
        event.preventDefault();
        const next_coords = move_cursor(event.key, [i, j], data);
        if (next_coords) {
          if (event.shiftKey) {
            $$invalidate(23, selected_cells = get_range_selection(selected_cells.length > 0 ? selected_cells[0] : [i, j], next_coords));
            $$invalidate(35, editing = false);
          } else {
            $$invalidate(23, selected_cells = [next_coords]);
            if (editable) {
              $$invalidate(35, editing = next_coords);
              $$invalidate(36, clear_on_focus = false);
            }
          }
          $$invalidate(24, selected = next_coords);
        } else if (next_coords === false && event.key === "ArrowUp" && i === 0) {
          $$invalidate(38, selected_header = j);
          $$invalidate(24, selected = false);
          $$invalidate(35, editing = false);
        }
        break;
      case "Escape":
        if (!editable)
          break;
        event.preventDefault();
        $$invalidate(35, editing = false);
        break;
      case "Enter":
        event.preventDefault();
        if (editable) {
          if (event.shiftKey) {
            add_row(i);
            await tick();
            $$invalidate(24, selected = [i + 1, j]);
          } else {
            if (dequal(editing, [i, j])) {
              const cell_id = data[i][j].id;
              const input_el = els[cell_id].input;
              if (input_el) {
                $$invalidate(27, data[i][j].value = input_el.value, data);
              }
              $$invalidate(35, editing = false);
              await tick();
              $$invalidate(24, selected = [i, j]);
            } else {
              $$invalidate(35, editing = [i, j]);
              $$invalidate(36, clear_on_focus = false);
            }
          }
        }
        break;
      case "Tab":
        event.preventDefault();
        $$invalidate(35, editing = false);
        const next_cell = get_next_cell_coordinates([i, j], data, event.shiftKey);
        if (next_cell) {
          $$invalidate(23, selected_cells = [next_cell]);
          $$invalidate(24, selected = next_cell);
          if (editable) {
            $$invalidate(35, editing = next_cell);
            $$invalidate(36, clear_on_focus = false);
          }
        }
        break;
      default:
        if (!editable)
          break;
        if ((!editing || editing && dequal(editing, [i, j])) && event.key.length === 1) {
          $$invalidate(36, clear_on_focus = true);
          $$invalidate(35, editing = [i, j]);
        }
    }
  }
  let sort_direction;
  let sort_by;
  function handle_sort(col, direction) {
    if (typeof sort_by !== "number" || sort_by !== col) {
      $$invalidate(28, sort_direction = direction);
      $$invalidate(29, sort_by = col);
    } else if (sort_by === col) {
      if (sort_direction === direction) {
        $$invalidate(28, sort_direction = void 0);
        $$invalidate(29, sort_by = void 0);
      } else {
        $$invalidate(28, sort_direction = direction);
      }
    }
  }
  async function edit_header(i, _select = false) {
    if (!editable || col_count[1] !== "dynamic" || header_edit === i)
      return;
    $$invalidate(24, selected = false);
    $$invalidate(23, selected_cells = []);
    $$invalidate(38, selected_header = i);
    $$invalidate(37, header_edit = i);
  }
  function end_header_edit(event) {
    if (!editable)
      return;
    switch (event.detail.key) {
      case "Escape":
      case "Enter":
      case "Tab":
        event.preventDefault();
        $$invalidate(24, selected = false);
        $$invalidate(38, selected_header = header_edit);
        $$invalidate(37, header_edit = false);
        parent.focus();
        break;
    }
  }
  async function add_row(index) {
    parent.focus();
    if (row_count[1] !== "dynamic")
      return;
    if (data.length === 0) {
      $$invalidate(0, values = [Array(headers.length).fill("")]);
      return;
    }
    const new_row = Array(data[0].length).fill(0).map((_, i) => {
      const _id = make_id();
      $$invalidate(25, els[_id] = { cell: null, input: null }, els);
      return { id: _id, value: "" };
    });
    if (index !== void 0 && index >= 0 && index <= data.length) {
      data.splice(index, 0, new_row);
    } else {
      data.push(new_row);
    }
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    $$invalidate(24, selected = [index !== void 0 ? index : data.length - 1, 0]);
  }
  async function add_col(index) {
    parent.focus();
    if (col_count[1] !== "dynamic")
      return;
    const insert_index = index !== void 0 ? index : data[0].length;
    for (let i = 0; i < data.length; i++) {
      const _id = make_id();
      $$invalidate(25, els[_id] = { cell: null, input: null }, els);
      data[i].splice(insert_index, 0, { id: _id, value: "" });
    }
    headers.splice(insert_index, 0, `Header ${headers.length + 1}`);
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    $$invalidate(71, headers);
    await tick();
    requestAnimationFrame(() => {
      edit_header(insert_index, true);
      const new_w = parent.querySelectorAll("tbody")[1].offsetWidth;
      parent.querySelectorAll("table")[1].scrollTo({ left: new_w });
    });
  }
  function handle_click_outside$1(event) {
    if (handle_click_outside(event, parent)) {
      $$invalidate(35, editing = false);
      $$invalidate(23, selected_cells = []);
      $$invalidate(37, header_edit = false);
      $$invalidate(38, selected_header = false);
      $$invalidate(39, active_cell_menu = null);
      $$invalidate(40, active_header_menu = null);
    }
  }
  let cells = [];
  let parent;
  let table;
  function set_cell_widths() {
    const widths = cells.map((el) => (el == null ? void 0 : el.clientWidth) || 0);
    if (widths.length === 0)
      return;
    if (show_row_numbers) {
      parent.style.setProperty(`--cell-width-row-number`, `${widths[0]}px`);
    }
    const data_cells = show_row_numbers ? widths.slice(1) : widths;
    data_cells.forEach((width, i) => {
      if (!column_widths[i]) {
        parent.style.setProperty(`--cell-width-${i}`, `${width - scrollbar_width / data_cells.length}px`);
      }
    });
  }
  function get_cell_width(index) {
    return column_widths[index] || `var(--cell-width-${index})`;
  }
  let table_height = values.slice(0, max_height / values.length * 37).length * 37 + 37;
  let scrollbar_width = 0;
  function sort_data2(_data, _display_value, _styling, col, dir) {
    let id = null;
    if (selected && selected[0] in _data && selected[1] in _data[selected[0]]) {
      id = _data[selected[0]][selected[1]].id;
    }
    if (typeof col !== "number" || !dir) {
      return;
    }
    sort_table_data(_data, _display_value, _styling, col, dir);
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    if (id) {
      const [i, j] = get_current_indices(id, data);
      $$invalidate(24, selected = [i, j]);
    }
  }
  let is_visible = false;
  onMount(() => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting && !is_visible) {
          set_cell_widths();
          $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
        }
        is_visible = entry.isIntersecting;
      });
    });
    observer.observe(parent);
    document.addEventListener("click", handle_click_outside$1);
    window.addEventListener("resize", handle_resize);
    document.addEventListener("fullscreenchange", handle_fullscreen_change);
    return () => {
      observer.disconnect();
      document.removeEventListener("click", handle_click_outside$1);
      window.removeEventListener("resize", handle_resize);
      document.removeEventListener("fullscreenchange", handle_fullscreen_change);
    };
  });
  function handle_cell_click(event, row, col) {
    if (event.target instanceof HTMLAnchorElement) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    if (show_row_numbers && col === -1)
      return;
    $$invalidate(36, clear_on_focus = false);
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
    $$invalidate(38, selected_header = false);
    $$invalidate(37, header_edit = false);
    $$invalidate(23, selected_cells = handle_selection([row, col], selected_cells, event));
    parent.focus();
    if (editable) {
      if (selected_cells.length === 1) {
        $$invalidate(35, editing = [row, col]);
        tick().then(() => {
          const input_el = els[data[row][col].id].input;
          if (input_el) {
            input_el.focus();
            input_el.selectionStart = input_el.selectionEnd = input_el.value.length;
          }
        });
      } else {
        $$invalidate(35, editing = false);
      }
    }
    toggle_cell_button(row, col);
    dispatch("select", {
      index: [row, col],
      value: get_data_at(row, col),
      row_value: data[row].map((d) => d.value)
    });
  }
  function toggle_cell_menu(event, row, col) {
    event.stopPropagation();
    if (active_cell_menu && active_cell_menu.row === row && active_cell_menu.col === col) {
      $$invalidate(39, active_cell_menu = null);
    } else {
      const cell = event.target.closest("td");
      if (cell) {
        const rect = cell.getBoundingClientRect();
        $$invalidate(39, active_cell_menu = { row, col, x: rect.right, y: rect.bottom });
      }
    }
  }
  function add_row_at(index, position) {
    const row_index = position === "above" ? index : index + 1;
    add_row(row_index);
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
  }
  function add_col_at(index, position) {
    const col_index = position === "left" ? index : index + 1;
    add_col(col_index);
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
  }
  function handle_resize() {
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
    $$invalidate(23, selected_cells = []);
    $$invalidate(24, selected = false);
    $$invalidate(35, editing = false);
    set_cell_widths();
  }
  let active_button = null;
  function toggle_header_button(col) {
    active_button = (active_button == null ? void 0 : active_button.type) === "header" && active_button.col === col ? null : { type: "header", col };
  }
  function toggle_cell_button(row, col) {
    active_button = (active_button == null ? void 0 : active_button.type) === "cell" && active_button.row === row && active_button.col === col ? null : { type: "cell", row, col };
  }
  function toggle_fullscreen() {
    if (!document.fullscreenElement) {
      parent.requestFullscreen();
      $$invalidate(41, is_fullscreen = true);
    } else {
      document.exitFullscreen();
      $$invalidate(41, is_fullscreen = false);
    }
  }
  function handle_fullscreen_change() {
    $$invalidate(41, is_fullscreen = !!document.fullscreenElement);
  }
  async function handle_copy() {
    await copy_table_data(data, selected_cells);
    $$invalidate(43, copy_flash = true);
    setTimeout(
      () => {
        $$invalidate(43, copy_flash = false);
      },
      800
    );
  }
  function toggle_header_menu(event, col) {
    event.stopPropagation();
    if (active_header_menu && active_header_menu.col === col) {
      $$invalidate(40, active_header_menu = null);
    } else {
      const header = event.target.closest("th");
      if (header) {
        const rect = header.getBoundingClientRect();
        $$invalidate(40, active_header_menu = { col, x: rect.right, y: rect.bottom });
      }
    }
  }
  afterUpdate(() => {
    $$invalidate(72, value_is_output = false);
  });
  async function delete_row(index) {
    parent.focus();
    if (row_count[1] !== "dynamic")
      return;
    if (data.length <= 1)
      return;
    data.splice(index, 1);
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    $$invalidate(24, selected = false);
  }
  async function delete_col(index) {
    parent.focus();
    if (col_count[1] !== "dynamic")
      return;
    if (data[0].length <= 1)
      return;
    _headers.splice(index, 1);
    $$invalidate(26, _headers), $$invalidate(71, headers), $$invalidate(74, old_headers), $$invalidate(4, col_count), $$invalidate(25, els);
    data.forEach((row) => {
      row.splice(index, 1);
    });
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    $$invalidate(24, selected = false);
  }
  function delete_row_at(index) {
    delete_row(index);
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
  }
  function delete_col_at(index) {
    delete_col(index);
    $$invalidate(39, active_cell_menu = null);
    $$invalidate(40, active_header_menu = null);
  }
  function handle_select_column(col) {
    $$invalidate(23, selected_cells = select_column(data, col));
    $$invalidate(24, selected = selected_cells[0]);
    $$invalidate(35, editing = false);
  }
  function handle_select_row(row) {
    $$invalidate(23, selected_cells = select_row(data, row));
    $$invalidate(24, selected = selected_cells[0]);
    $$invalidate(35, editing = false);
  }
  let coords;
  let current_search_query = null;
  function handle_search(search_query) {
    $$invalidate(47, current_search_query = search_query);
    dispatch("search", search_query);
  }
  function commit_filter() {
    if (current_search_query && show_search === "filter") {
      dispatch("change", {
        data: data.map((row) => row.map((cell) => cell.value)),
        headers: _headers.map((h) => h.value),
        metadata: null
      });
      if (!value_is_output) {
        dispatch("input");
      }
      $$invalidate(47, current_search_query = null);
    }
  }
  const resize_handler = () => set_cell_widths();
  const search_handler = (e) => handle_search(e.detail);
  const click_handler = () => handle_select_column(coords[1]);
  const click_handler_1 = () => handle_select_row(coords[0]);
  const sort_handler = (i, { detail }) => handle_sort(i, detail);
  function td_binding($$value, j) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      cells[j] = $$value;
      $$invalidate(30, cells);
    });
  }
  function table_1_elementresizecontentbox_handler() {
    var _a;
    t_rect = (_a = ResizeObserverSingleton.entries.get(this)) == null ? void 0 : _a.contentRect;
    $$invalidate(34, t_rect);
  }
  function table_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      table = $$value;
      $$invalidate(32, table);
    });
  }
  function editablecell_value_binding(value, index, j) {
    if ($$self.$$.not_equal(data[index][j].value, value)) {
      data[index][j].value = value;
      $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
    }
  }
  function editablecell_el_binding(value, id) {
    if ($$self.$$.not_equal(els[id].input, value)) {
      els[id].input = value;
      $$invalidate(25, els);
    }
  }
  const blur_handler = () => {
    $$invalidate(36, clear_on_focus = false);
    parent.focus();
  };
  const focus_handler = (index, j) => {
    const row = index;
    const col = j;
    if (!selected_cells.some(([r, c]) => r === row && c === col)) {
      $$invalidate(23, selected_cells = [[row, col]]);
    }
  };
  const click_handler_2 = (index, j, event) => toggle_cell_menu(event, index, j);
  function td_binding_1($$value, id) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      els[id].cell = $$value;
      $$invalidate(25, els);
    });
  }
  const touchstart_handler = (index, j, event) => {
    const touch = event.touches[0];
    const mouseEvent = new MouseEvent(
      "click",
      {
        clientX: touch.clientX,
        clientY: touch.clientY,
        bubbles: true,
        cancelable: true,
        view: window
      }
    );
    handle_cell_click(mouseEvent, index, j);
  };
  const click_handler_3 = (index, j, event) => handle_cell_click(event, index, j);
  function editablecell_value_binding_1(value, i) {
    if ($$self.$$.not_equal(_headers[i].value, value)) {
      _headers[i].value = value;
      $$invalidate(26, _headers), $$invalidate(71, headers), $$invalidate(74, old_headers), $$invalidate(4, col_count), $$invalidate(25, els);
    }
  }
  function editablecell_el_binding_1(value, id) {
    if ($$self.$$.not_equal(els[id].input, value)) {
      els[id].input = value;
      $$invalidate(25, els);
    }
  }
  const dblclick_handler = (i) => edit_header(i);
  const sort_handler_1 = (i, { detail }) => handle_sort(i, detail);
  const click_handler_4 = (i, event) => toggle_header_menu(event, i);
  const click_handler_5 = (i) => {
    toggle_header_button(i);
  };
  function virtualtable_items_binding(value) {
    data = value;
    $$invalidate(27, data), $$invalidate(0, values), $$invalidate(75, old_val);
  }
  function virtualtable_actual_height_binding(value) {
    table_height = value;
    $$invalidate(44, table_height);
  }
  function virtualtable_table_scrollbar_width_binding(value) {
    scrollbar_width = value;
    $$invalidate(45, scrollbar_width);
  }
  function upload_1_dragging_binding(value) {
    dragging = value;
    $$invalidate(42, dragging);
  }
  const load_handler = ({ detail }) => handle_file_upload(
    detail.data,
    (head) => {
      $$invalidate(26, _headers = make_headers(head.map((h) => h ?? ""), col_count, els));
      return _headers;
    },
    (vals) => {
      $$invalidate(0, values = vals);
    }
  );
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      parent = $$value;
      $$invalidate(31, parent);
    });
  }
  const keydown_handler = (e) => handle_keydown(e);
  const func_3 = () => add_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) || 0, "above");
  const func_4 = () => add_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) || 0, "below");
  const func_5 = () => add_col_at((active_cell_menu == null ? void 0 : active_cell_menu.col) || 0, "left");
  const func_6 = () => add_col_at((active_cell_menu == null ? void 0 : active_cell_menu.col) || 0, "right");
  const func_7 = () => delete_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) || 0);
  const func_8 = () => delete_col_at((active_cell_menu == null ? void 0 : active_cell_menu.col) || 0);
  const func_9 = () => add_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) ?? -1, "above");
  const func_10 = () => add_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) ?? -1, "below");
  const func_11 = () => add_col_at((active_header_menu == null ? void 0 : active_header_menu.col) ?? -1, "left");
  const func_12 = () => add_col_at((active_header_menu == null ? void 0 : active_header_menu.col) ?? -1, "right");
  const func_13 = () => delete_row_at((active_cell_menu == null ? void 0 : active_cell_menu.row) ?? -1);
  const func_14 = () => delete_col_at((active_header_menu == null ? void 0 : active_header_menu.col) ?? -1);
  $$self.$$set = ($$props2) => {
    if ("datatype" in $$props2)
      $$invalidate(1, datatype = $$props2.datatype);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("show_label" in $$props2)
      $$invalidate(3, show_label = $$props2.show_label);
    if ("headers" in $$props2)
      $$invalidate(71, headers = $$props2.headers);
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("col_count" in $$props2)
      $$invalidate(4, col_count = $$props2.col_count);
    if ("row_count" in $$props2)
      $$invalidate(5, row_count = $$props2.row_count);
    if ("latex_delimiters" in $$props2)
      $$invalidate(6, latex_delimiters = $$props2.latex_delimiters);
    if ("editable" in $$props2)
      $$invalidate(7, editable = $$props2.editable);
    if ("wrap" in $$props2)
      $$invalidate(8, wrap = $$props2.wrap);
    if ("root" in $$props2)
      $$invalidate(9, root = $$props2.root);
    if ("i18n" in $$props2)
      $$invalidate(10, i18n = $$props2.i18n);
    if ("max_height" in $$props2)
      $$invalidate(11, max_height = $$props2.max_height);
    if ("line_breaks" in $$props2)
      $$invalidate(12, line_breaks = $$props2.line_breaks);
    if ("column_widths" in $$props2)
      $$invalidate(13, column_widths = $$props2.column_widths);
    if ("show_row_numbers" in $$props2)
      $$invalidate(14, show_row_numbers = $$props2.show_row_numbers);
    if ("upload" in $$props2)
      $$invalidate(15, upload = $$props2.upload);
    if ("stream_handler" in $$props2)
      $$invalidate(16, stream_handler = $$props2.stream_handler);
    if ("show_fullscreen_button" in $$props2)
      $$invalidate(17, show_fullscreen_button = $$props2.show_fullscreen_button);
    if ("show_copy_button" in $$props2)
      $$invalidate(18, show_copy_button = $$props2.show_copy_button);
    if ("value_is_output" in $$props2)
      $$invalidate(72, value_is_output = $$props2.value_is_output);
    if ("max_chars" in $$props2)
      $$invalidate(19, max_chars = $$props2.max_chars);
    if ("show_search" in $$props2)
      $$invalidate(20, show_search = $$props2.show_search);
    if ("pinned_columns" in $$props2)
      $$invalidate(73, pinned_columns = $$props2.pinned_columns);
    if ("display_value" in $$props2)
      $$invalidate(21, display_value = $$props2.display_value);
    if ("styling" in $$props2)
      $$invalidate(22, styling = $$props2.styling);
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty[0] & /*values*/
    1 | $$self.$$.dirty[2] & /*old_val*/
    8192) {
      if (!dequal(values, old_val)) {
        $$invalidate(27, data = process_data(values));
        $$invalidate(75, old_val = JSON.parse(JSON.stringify(values)));
      }
    }
    if ($$self.$$.dirty[0] & /*data*/
    134217728 | $$self.$$.dirty[2] & /*pinned_columns*/
    2048) {
      $$invalidate(33, actual_pinned_columns = pinned_columns && ((_a = data == null ? void 0 : data[0]) == null ? void 0 : _a.length) ? Math.min(pinned_columns, data[0].length) : 0);
    }
    if ($$self.$$.dirty[0] & /*selected_cells*/
    8388608) {
      $$invalidate(23, selected_cells = [...selected_cells]);
    }
    if ($$self.$$.dirty[0] & /*selected_cells*/
    8388608) {
      $$invalidate(24, selected = selected_cells.length > 0 ? selected_cells[selected_cells.length - 1] : false);
    }
    if ($$self.$$.dirty[0] & /*col_count, els*/
    33554448 | $$self.$$.dirty[2] & /*headers, old_headers*/
    4608) {
      {
        if (!dequal(headers, old_headers)) {
          $$invalidate(26, _headers = make_headers(headers, col_count, els));
          $$invalidate(74, old_headers = JSON.parse(JSON.stringify(headers)));
        }
      }
    }
    if ($$self.$$.dirty[0] & /*data, _headers*/
    201326592) {
      (data || _headers) && trigger_change();
    }
    if ($$self.$$.dirty[0] & /*data*/
    134217728) {
      $$invalidate(49, max = get_max(data));
    }
    if ($$self.$$.dirty[0] & /*cells*/
    1073741824) {
      cells[0] && set_cell_widths();
    }
    if ($$self.$$.dirty[0] & /*data, display_value, styling, sort_by, sort_direction*/
    945815552) {
      sort_data2(data, display_value, styling, sort_by, sort_direction);
    }
    if ($$self.$$.dirty[0] & /*selected*/
    16777216) {
      $$invalidate(48, selected_index = !!selected && selected[0]);
    }
    if ($$self.$$.dirty[0] & /*sort_by, sort_direction, data*/
    939524096) {
      {
        if (typeof sort_by === "number" && sort_direction && sort_by >= 0 && sort_by < data[0].length) {
          const indices = [...Array(data.length)].map((_, i) => i);
          const sort_index = sort_by;
          indices.sort((a, b) => {
            const row_a = data[a];
            const row_b = data[b];
            if (!row_a || !row_b || sort_index >= row_a.length || sort_index >= row_b.length)
              return 0;
            const val_a = row_a[sort_index].value;
            const val_b = row_b[sort_index].value;
            const comp = val_a < val_b ? -1 : val_a > val_b ? 1 : 0;
            return sort_direction === "asc" ? comp : -comp;
          });
        } else {
          [...Array(data.length)].map((_, i) => i);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*selected*/
    16777216) {
      if (selected !== false)
        $$invalidate(46, coords = selected);
    }
    if ($$self.$$.dirty[0] & /*selected, data, els*/
    184549376 | $$self.$$.dirty[1] & /*parent, table*/
    3) {
      if (selected !== false) {
        const positions = calculate_selection_positions(selected, data, els, parent, table);
        document.documentElement.style.setProperty("--selected-col-pos", positions.col_pos);
        if (positions.row_pos) {
          document.documentElement.style.setProperty("--selected-row-pos", positions.row_pos);
        }
      }
    }
  };
  return [
    values,
    datatype,
    label,
    show_label,
    col_count,
    row_count,
    latex_delimiters,
    editable,
    wrap,
    root,
    i18n,
    max_height,
    line_breaks,
    column_widths,
    show_row_numbers,
    upload,
    stream_handler,
    show_fullscreen_button,
    show_copy_button,
    max_chars,
    show_search,
    display_value,
    styling,
    selected_cells,
    selected,
    els,
    _headers,
    data,
    sort_direction,
    sort_by,
    cells,
    parent,
    table,
    actual_pinned_columns,
    t_rect,
    editing,
    clear_on_focus,
    header_edit,
    selected_header,
    active_cell_menu,
    active_header_menu,
    is_fullscreen,
    dragging,
    copy_flash,
    table_height,
    scrollbar_width,
    coords,
    current_search_query,
    selected_index,
    max,
    get_sort_status,
    handle_keydown,
    handle_sort,
    edit_header,
    end_header_edit,
    set_cell_widths,
    get_cell_width,
    handle_cell_click,
    toggle_cell_menu,
    add_row_at,
    add_col_at,
    toggle_header_button,
    toggle_fullscreen,
    handle_copy,
    toggle_header_menu,
    delete_row_at,
    delete_col_at,
    handle_select_column,
    handle_select_row,
    handle_search,
    commit_filter,
    headers,
    value_is_output,
    pinned_columns,
    old_headers,
    old_val,
    resize_handler,
    search_handler,
    click_handler,
    click_handler_1,
    sort_handler,
    td_binding,
    table_1_elementresizecontentbox_handler,
    table_1_binding,
    editablecell_value_binding,
    editablecell_el_binding,
    blur_handler,
    focus_handler,
    click_handler_2,
    td_binding_1,
    touchstart_handler,
    click_handler_3,
    editablecell_value_binding_1,
    editablecell_el_binding_1,
    dblclick_handler,
    sort_handler_1,
    click_handler_4,
    click_handler_5,
    virtualtable_items_binding,
    virtualtable_actual_height_binding,
    virtualtable_table_scrollbar_width_binding,
    upload_1_dragging_binding,
    load_handler,
    div1_binding,
    keydown_handler,
    func_3,
    func_4,
    func_5,
    func_6,
    func_7,
    func_8,
    func_9,
    func_10,
    func_11,
    func_12,
    func_13,
    func_14
  ];
}
class Table extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1,
      create_fragment$1,
      safe_not_equal,
      {
        datatype: 1,
        label: 2,
        show_label: 3,
        headers: 71,
        values: 0,
        col_count: 4,
        row_count: 5,
        latex_delimiters: 6,
        editable: 7,
        wrap: 8,
        root: 9,
        i18n: 10,
        max_height: 11,
        line_breaks: 12,
        column_widths: 13,
        show_row_numbers: 14,
        upload: 15,
        stream_handler: 16,
        show_fullscreen_button: 17,
        show_copy_button: 18,
        value_is_output: 72,
        max_chars: 19,
        show_search: 20,
        pinned_columns: 73,
        display_value: 21,
        styling: 22
      },
      null,
      [-1, -1, -1, -1, -1]
    );
  }
}
const Table$1 = Table;
function create_default_slot(ctx) {
  let statustracker;
  let t;
  let table;
  let updating_value_is_output;
  let current;
  const statustracker_spread_levels = [
    {
      autoscroll: (
        /*gradio*/
        ctx[16].autoscroll
      )
    },
    { i18n: (
      /*gradio*/
      ctx[16].i18n
    ) },
    /*loading_status*/
    ctx[19]
  ];
  let statustracker_props = {};
  for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
    statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
  }
  statustracker = new Static({ props: statustracker_props });
  statustracker.$on(
    "clear_status",
    /*clear_status_handler*/
    ctx[33]
  );
  function table_value_is_output_binding(value) {
    ctx[36](value);
  }
  let table_props = {
    root: (
      /*root*/
      ctx[13]
    ),
    label: (
      /*label*/
      ctx[7]
    ),
    show_label: (
      /*show_label*/
      ctx[8]
    ),
    row_count: (
      /*row_count*/
      ctx[6]
    ),
    col_count: (
      /*col_count*/
      ctx[5]
    ),
    values: (
      /*filtered_cell_values*/
      ctx[31] || /*value*/
      ctx[0].data
    ),
    display_value: (
      /*display_value*/
      ctx[29]
    ),
    styling: (
      /*styling*/
      ctx[28]
    ),
    headers: (
      /*_headers*/
      ctx[30]
    ),
    wrap: (
      /*wrap*/
      ctx[9]
    ),
    datatype: (
      /*datatype*/
      ctx[10]
    ),
    latex_delimiters: (
      /*latex_delimiters*/
      ctx[17]
    ),
    editable: (
      /*interactive*/
      ctx[20]
    ),
    max_height: (
      /*max_height*/
      ctx[18]
    ),
    i18n: (
      /*gradio*/
      ctx[16].i18n
    ),
    line_breaks: (
      /*line_breaks*/
      ctx[14]
    ),
    column_widths: (
      /*column_widths*/
      ctx[15]
    ),
    upload: (
      /*func*/
      ctx[34]
    ),
    stream_handler: (
      /*func_1*/
      ctx[35]
    ),
    show_fullscreen_button: (
      /*show_fullscreen_button*/
      ctx[21]
    ),
    max_chars: (
      /*max_chars*/
      ctx[22]
    ),
    show_copy_button: (
      /*show_copy_button*/
      ctx[23]
    ),
    show_row_numbers: (
      /*show_row_numbers*/
      ctx[24]
    ),
    show_search: (
      /*show_search*/
      ctx[25]
    ),
    pinned_columns: (
      /*pinned_columns*/
      ctx[26]
    )
  };
  if (
    /*value_is_output*/
    ctx[1] !== void 0
  ) {
    table_props.value_is_output = /*value_is_output*/
    ctx[1];
  }
  table = new Table$1({ props: table_props });
  binding_callbacks.push(() => bind(table, "value_is_output", table_value_is_output_binding));
  table.$on(
    "change",
    /*change_handler*/
    ctx[37]
  );
  table.$on(
    "input",
    /*input_handler*/
    ctx[38]
  );
  table.$on(
    "select",
    /*select_handler*/
    ctx[39]
  );
  table.$on(
    "search",
    /*search_handler*/
    ctx[40]
  );
  return {
    c() {
      create_component(statustracker.$$.fragment);
      t = space();
      create_component(table.$$.fragment);
    },
    l(nodes) {
      claim_component(statustracker.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(table.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(statustracker, target, anchor);
      insert_hydration(target, t, anchor);
      mount_component(table, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const statustracker_changes = dirty[0] & /*gradio, loading_status*/
      589824 ? get_spread_update(statustracker_spread_levels, [
        dirty[0] & /*gradio*/
        65536 && {
          autoscroll: (
            /*gradio*/
            ctx2[16].autoscroll
          )
        },
        dirty[0] & /*gradio*/
        65536 && { i18n: (
          /*gradio*/
          ctx2[16].i18n
        ) },
        dirty[0] & /*loading_status*/
        524288 && get_spread_object(
          /*loading_status*/
          ctx2[19]
        )
      ]) : {};
      statustracker.$set(statustracker_changes);
      const table_changes = {};
      if (dirty[0] & /*root*/
      8192)
        table_changes.root = /*root*/
        ctx2[13];
      if (dirty[0] & /*label*/
      128)
        table_changes.label = /*label*/
        ctx2[7];
      if (dirty[0] & /*show_label*/
      256)
        table_changes.show_label = /*show_label*/
        ctx2[8];
      if (dirty[0] & /*row_count*/
      64)
        table_changes.row_count = /*row_count*/
        ctx2[6];
      if (dirty[0] & /*col_count*/
      32)
        table_changes.col_count = /*col_count*/
        ctx2[5];
      if (dirty[0] & /*value*/
      1 | dirty[1] & /*filtered_cell_values*/
      1)
        table_changes.values = /*filtered_cell_values*/
        ctx2[31] || /*value*/
        ctx2[0].data;
      if (dirty[0] & /*display_value*/
      536870912)
        table_changes.display_value = /*display_value*/
        ctx2[29];
      if (dirty[0] & /*styling*/
      268435456)
        table_changes.styling = /*styling*/
        ctx2[28];
      if (dirty[0] & /*_headers*/
      1073741824)
        table_changes.headers = /*_headers*/
        ctx2[30];
      if (dirty[0] & /*wrap*/
      512)
        table_changes.wrap = /*wrap*/
        ctx2[9];
      if (dirty[0] & /*datatype*/
      1024)
        table_changes.datatype = /*datatype*/
        ctx2[10];
      if (dirty[0] & /*latex_delimiters*/
      131072)
        table_changes.latex_delimiters = /*latex_delimiters*/
        ctx2[17];
      if (dirty[0] & /*interactive*/
      1048576)
        table_changes.editable = /*interactive*/
        ctx2[20];
      if (dirty[0] & /*max_height*/
      262144)
        table_changes.max_height = /*max_height*/
        ctx2[18];
      if (dirty[0] & /*gradio*/
      65536)
        table_changes.i18n = /*gradio*/
        ctx2[16].i18n;
      if (dirty[0] & /*line_breaks*/
      16384)
        table_changes.line_breaks = /*line_breaks*/
        ctx2[14];
      if (dirty[0] & /*column_widths*/
      32768)
        table_changes.column_widths = /*column_widths*/
        ctx2[15];
      if (dirty[0] & /*gradio*/
      65536)
        table_changes.upload = /*func*/
        ctx2[34];
      if (dirty[0] & /*gradio*/
      65536)
        table_changes.stream_handler = /*func_1*/
        ctx2[35];
      if (dirty[0] & /*show_fullscreen_button*/
      2097152)
        table_changes.show_fullscreen_button = /*show_fullscreen_button*/
        ctx2[21];
      if (dirty[0] & /*max_chars*/
      4194304)
        table_changes.max_chars = /*max_chars*/
        ctx2[22];
      if (dirty[0] & /*show_copy_button*/
      8388608)
        table_changes.show_copy_button = /*show_copy_button*/
        ctx2[23];
      if (dirty[0] & /*show_row_numbers*/
      16777216)
        table_changes.show_row_numbers = /*show_row_numbers*/
        ctx2[24];
      if (dirty[0] & /*show_search*/
      33554432)
        table_changes.show_search = /*show_search*/
        ctx2[25];
      if (dirty[0] & /*pinned_columns*/
      67108864)
        table_changes.pinned_columns = /*pinned_columns*/
        ctx2[26];
      if (!updating_value_is_output && dirty[0] & /*value_is_output*/
      2) {
        updating_value_is_output = true;
        table_changes.value_is_output = /*value_is_output*/
        ctx2[1];
        add_flush_callback(() => updating_value_is_output = false);
      }
      table.$set(table_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(statustracker.$$.fragment, local);
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(statustracker.$$.fragment, local);
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(statustracker, detaching);
      destroy_component(table, detaching);
    }
  };
}
function create_fragment(ctx) {
  let block;
  let current;
  block = new Block({
    props: {
      visible: (
        /*visible*/
        ctx[4]
      ),
      padding: false,
      elem_id: (
        /*elem_id*/
        ctx[2]
      ),
      elem_classes: (
        /*elem_classes*/
        ctx[3]
      ),
      container: false,
      scale: (
        /*scale*/
        ctx[11]
      ),
      min_width: (
        /*min_width*/
        ctx[12]
      ),
      overflow_behavior: "visible",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(block.$$.fragment);
    },
    l(nodes) {
      claim_component(block.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(block, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const block_changes = {};
      if (dirty[0] & /*visible*/
      16)
        block_changes.visible = /*visible*/
        ctx2[4];
      if (dirty[0] & /*elem_id*/
      4)
        block_changes.elem_id = /*elem_id*/
        ctx2[2];
      if (dirty[0] & /*elem_classes*/
      8)
        block_changes.elem_classes = /*elem_classes*/
        ctx2[3];
      if (dirty[0] & /*scale*/
      2048)
        block_changes.scale = /*scale*/
        ctx2[11];
      if (dirty[0] & /*min_width*/
      4096)
        block_changes.min_width = /*min_width*/
        ctx2[12];
      if (dirty[0] & /*root, label, show_label, row_count, col_count, value, display_value, styling, _headers, wrap, datatype, latex_delimiters, interactive, max_height, gradio, line_breaks, column_widths, show_fullscreen_button, max_chars, show_copy_button, show_row_numbers, show_search, pinned_columns, value_is_output, search_query, loading_status*/
      2147477475 | dirty[1] & /*$$scope, filtered_cell_values*/
      1025) {
        block_changes.$$scope = { dirty, ctx: ctx2 };
      }
      block.$set(block_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(block.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(block.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(block, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let filtered_cell_values;
  let _headers;
  let display_value;
  let styling;
  let { headers = [] } = $$props;
  let { elem_id = "" } = $$props;
  let { elem_classes = [] } = $$props;
  let { visible = true } = $$props;
  let { value = {
    data: [["", "", ""]],
    headers: ["1", "2", "3"],
    metadata: null
  } } = $$props;
  let { value_is_output = false } = $$props;
  let { col_count } = $$props;
  let { row_count } = $$props;
  let { label = null } = $$props;
  let { show_label = true } = $$props;
  let { wrap } = $$props;
  let { datatype } = $$props;
  let { scale = null } = $$props;
  let { min_width = void 0 } = $$props;
  let { root } = $$props;
  let { line_breaks = true } = $$props;
  let { column_widths = [] } = $$props;
  let { gradio } = $$props;
  let { latex_delimiters } = $$props;
  let { max_height = void 0 } = $$props;
  let { loading_status } = $$props;
  let { interactive } = $$props;
  let { show_fullscreen_button = false } = $$props;
  let { max_chars = void 0 } = $$props;
  let { show_copy_button = false } = $$props;
  let { show_row_numbers = false } = $$props;
  let { show_search = "none" } = $$props;
  let search_query = null;
  let { pinned_columns = 0 } = $$props;
  const clear_status_handler = () => gradio.dispatch("clear_status", loading_status);
  const func2 = (...args) => gradio.client.upload(...args);
  const func_12 = (...args) => gradio.client.stream(...args);
  function table_value_is_output_binding(value2) {
    value_is_output = value2;
    $$invalidate(1, value_is_output);
  }
  const change_handler = (e) => {
    $$invalidate(0, value = e.detail);
    gradio.dispatch("change");
  };
  const input_handler = (e) => gradio.dispatch("input");
  const select_handler = (e) => gradio.dispatch("select", e.detail);
  const search_handler = (e) => $$invalidate(27, search_query = e.detail);
  $$self.$$set = ($$props2) => {
    if ("headers" in $$props2)
      $$invalidate(32, headers = $$props2.headers);
    if ("elem_id" in $$props2)
      $$invalidate(2, elem_id = $$props2.elem_id);
    if ("elem_classes" in $$props2)
      $$invalidate(3, elem_classes = $$props2.elem_classes);
    if ("visible" in $$props2)
      $$invalidate(4, visible = $$props2.visible);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("value_is_output" in $$props2)
      $$invalidate(1, value_is_output = $$props2.value_is_output);
    if ("col_count" in $$props2)
      $$invalidate(5, col_count = $$props2.col_count);
    if ("row_count" in $$props2)
      $$invalidate(6, row_count = $$props2.row_count);
    if ("label" in $$props2)
      $$invalidate(7, label = $$props2.label);
    if ("show_label" in $$props2)
      $$invalidate(8, show_label = $$props2.show_label);
    if ("wrap" in $$props2)
      $$invalidate(9, wrap = $$props2.wrap);
    if ("datatype" in $$props2)
      $$invalidate(10, datatype = $$props2.datatype);
    if ("scale" in $$props2)
      $$invalidate(11, scale = $$props2.scale);
    if ("min_width" in $$props2)
      $$invalidate(12, min_width = $$props2.min_width);
    if ("root" in $$props2)
      $$invalidate(13, root = $$props2.root);
    if ("line_breaks" in $$props2)
      $$invalidate(14, line_breaks = $$props2.line_breaks);
    if ("column_widths" in $$props2)
      $$invalidate(15, column_widths = $$props2.column_widths);
    if ("gradio" in $$props2)
      $$invalidate(16, gradio = $$props2.gradio);
    if ("latex_delimiters" in $$props2)
      $$invalidate(17, latex_delimiters = $$props2.latex_delimiters);
    if ("max_height" in $$props2)
      $$invalidate(18, max_height = $$props2.max_height);
    if ("loading_status" in $$props2)
      $$invalidate(19, loading_status = $$props2.loading_status);
    if ("interactive" in $$props2)
      $$invalidate(20, interactive = $$props2.interactive);
    if ("show_fullscreen_button" in $$props2)
      $$invalidate(21, show_fullscreen_button = $$props2.show_fullscreen_button);
    if ("max_chars" in $$props2)
      $$invalidate(22, max_chars = $$props2.max_chars);
    if ("show_copy_button" in $$props2)
      $$invalidate(23, show_copy_button = $$props2.show_copy_button);
    if ("show_row_numbers" in $$props2)
      $$invalidate(24, show_row_numbers = $$props2.show_row_numbers);
    if ("show_search" in $$props2)
      $$invalidate(25, show_search = $$props2.show_search);
    if ("pinned_columns" in $$props2)
      $$invalidate(26, pinned_columns = $$props2.pinned_columns);
  };
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e;
    if ($$self.$$.dirty[0] & /*search_query, value*/
    134217729) {
      $$invalidate(31, filtered_cell_values = search_query ? (_a = value.data) == null ? void 0 : _a.filter((row) => row.some((cell) => search_query && String(cell).toLowerCase().includes(search_query.toLowerCase()))) : null);
    }
    if ($$self.$$.dirty[0] & /*value*/
    1 | $$self.$$.dirty[1] & /*headers*/
    2) {
      $$invalidate(30, _headers = [...value.headers || headers]);
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $$invalidate(29, display_value = ((_b = value == null ? void 0 : value.metadata) == null ? void 0 : _b.display_value) ? [...(_c = value == null ? void 0 : value.metadata) == null ? void 0 : _c.display_value] : null);
    }
    if ($$self.$$.dirty[0] & /*interactive, value*/
    1048577) {
      $$invalidate(28, styling = !interactive && ((_d = value == null ? void 0 : value.metadata) == null ? void 0 : _d.styling) ? [...(_e = value == null ? void 0 : value.metadata) == null ? void 0 : _e.styling] : null);
    }
  };
  return [
    value,
    value_is_output,
    elem_id,
    elem_classes,
    visible,
    col_count,
    row_count,
    label,
    show_label,
    wrap,
    datatype,
    scale,
    min_width,
    root,
    line_breaks,
    column_widths,
    gradio,
    latex_delimiters,
    max_height,
    loading_status,
    interactive,
    show_fullscreen_button,
    max_chars,
    show_copy_button,
    show_row_numbers,
    show_search,
    pinned_columns,
    search_query,
    styling,
    display_value,
    _headers,
    filtered_cell_values,
    headers,
    clear_status_handler,
    func2,
    func_12,
    table_value_is_output_binding,
    change_handler,
    input_handler,
    select_handler,
    search_handler
  ];
}
class Index extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        headers: 32,
        elem_id: 2,
        elem_classes: 3,
        visible: 4,
        value: 0,
        value_is_output: 1,
        col_count: 5,
        row_count: 6,
        label: 7,
        show_label: 8,
        wrap: 9,
        datatype: 10,
        scale: 11,
        min_width: 12,
        root: 13,
        line_breaks: 14,
        column_widths: 15,
        gradio: 16,
        latex_delimiters: 17,
        max_height: 18,
        loading_status: 19,
        interactive: 20,
        show_fullscreen_button: 21,
        max_chars: 22,
        show_copy_button: 23,
        show_row_numbers: 24,
        show_search: 25,
        pinned_columns: 26
      },
      null,
      [-1, -1]
    );
  }
  get headers() {
    return this.$$.ctx[32];
  }
  set headers(headers) {
    this.$$set({ headers });
    flush();
  }
  get elem_id() {
    return this.$$.ctx[2];
  }
  set elem_id(elem_id) {
    this.$$set({ elem_id });
    flush();
  }
  get elem_classes() {
    return this.$$.ctx[3];
  }
  set elem_classes(elem_classes) {
    this.$$set({ elem_classes });
    flush();
  }
  get visible() {
    return this.$$.ctx[4];
  }
  set visible(visible) {
    this.$$set({ visible });
    flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(value) {
    this.$$set({ value });
    flush();
  }
  get value_is_output() {
    return this.$$.ctx[1];
  }
  set value_is_output(value_is_output) {
    this.$$set({ value_is_output });
    flush();
  }
  get col_count() {
    return this.$$.ctx[5];
  }
  set col_count(col_count) {
    this.$$set({ col_count });
    flush();
  }
  get row_count() {
    return this.$$.ctx[6];
  }
  set row_count(row_count) {
    this.$$set({ row_count });
    flush();
  }
  get label() {
    return this.$$.ctx[7];
  }
  set label(label) {
    this.$$set({ label });
    flush();
  }
  get show_label() {
    return this.$$.ctx[8];
  }
  set show_label(show_label) {
    this.$$set({ show_label });
    flush();
  }
  get wrap() {
    return this.$$.ctx[9];
  }
  set wrap(wrap) {
    this.$$set({ wrap });
    flush();
  }
  get datatype() {
    return this.$$.ctx[10];
  }
  set datatype(datatype) {
    this.$$set({ datatype });
    flush();
  }
  get scale() {
    return this.$$.ctx[11];
  }
  set scale(scale) {
    this.$$set({ scale });
    flush();
  }
  get min_width() {
    return this.$$.ctx[12];
  }
  set min_width(min_width) {
    this.$$set({ min_width });
    flush();
  }
  get root() {
    return this.$$.ctx[13];
  }
  set root(root) {
    this.$$set({ root });
    flush();
  }
  get line_breaks() {
    return this.$$.ctx[14];
  }
  set line_breaks(line_breaks) {
    this.$$set({ line_breaks });
    flush();
  }
  get column_widths() {
    return this.$$.ctx[15];
  }
  set column_widths(column_widths) {
    this.$$set({ column_widths });
    flush();
  }
  get gradio() {
    return this.$$.ctx[16];
  }
  set gradio(gradio) {
    this.$$set({ gradio });
    flush();
  }
  get latex_delimiters() {
    return this.$$.ctx[17];
  }
  set latex_delimiters(latex_delimiters) {
    this.$$set({ latex_delimiters });
    flush();
  }
  get max_height() {
    return this.$$.ctx[18];
  }
  set max_height(max_height) {
    this.$$set({ max_height });
    flush();
  }
  get loading_status() {
    return this.$$.ctx[19];
  }
  set loading_status(loading_status) {
    this.$$set({ loading_status });
    flush();
  }
  get interactive() {
    return this.$$.ctx[20];
  }
  set interactive(interactive) {
    this.$$set({ interactive });
    flush();
  }
  get show_fullscreen_button() {
    return this.$$.ctx[21];
  }
  set show_fullscreen_button(show_fullscreen_button) {
    this.$$set({ show_fullscreen_button });
    flush();
  }
  get max_chars() {
    return this.$$.ctx[22];
  }
  set max_chars(max_chars) {
    this.$$set({ max_chars });
    flush();
  }
  get show_copy_button() {
    return this.$$.ctx[23];
  }
  set show_copy_button(show_copy_button) {
    this.$$set({ show_copy_button });
    flush();
  }
  get show_row_numbers() {
    return this.$$.ctx[24];
  }
  set show_row_numbers(show_row_numbers) {
    this.$$set({ show_row_numbers });
    flush();
  }
  get show_search() {
    return this.$$.ctx[25];
  }
  set show_search(show_search) {
    this.$$set({ show_search });
    flush();
  }
  get pinned_columns() {
    return this.$$.ctx[26];
  }
  set pinned_columns(pinned_columns) {
    this.$$set({ pinned_columns });
    flush();
  }
}
export {
  Table$1 as BaseDataFrame,
  default2 as BaseExample,
  Index as default
};
